import { isNil } from "@compas/stdlib";

/**
 * Format and append query parts, and execute the final result in a safe way.
 * Undefined values are skipped, as they are not allowed in queries.
 * The query call may be one of the interpolated values. Supports being called as a template literal.
 *
 * @since 0.1.0
 *
 * @template {*} T
 * @param {string[]} strings
 * @param {...*} values
 * @returns {QueryPart<T>}
 */
export function query(strings, ...values) {
  let _strings = [];
  const _values = [];

  const result = {
    get strings() {
      return _strings;
    },
    get values() {
      return _values;
    },
    append,
    exec,
  };

  // Flatten nested query parts
  let didFlatten = false;
  for (let i = 0; i < strings.length - 1; ++i) {
    if (didFlatten) {
      didFlatten = false;
      _strings[_strings.length - 1] += strings[i];
    } else {
      _strings.push(strings[i]);
    }
    if (isQueryPart(values[i])) {
      append(values[i]);
      didFlatten = true;
    } else {
      _values.push(values[i]);
    }
  }

  if (didFlatten) {
    _strings[_strings.length - 1] += strings[strings.length - 1];
  } else {
    _strings.push(strings[strings.length - 1]);
  }

  return result;

  function append(query) {
    const last = _strings[_strings.length - 1];
    const [first, ...rest] = query.strings;
    _strings = [..._strings.slice(0, -1), `${last} ${first}`, ...rest];
    _values.push.apply(_values, query.values);
    return result;
  }

  async function exec(sql) {
    let str = _strings[0];
    let valueIdx = 1;
    for (let i = 0; i < _values.length; ++i) {
      if (_values[i] === undefined) {
        str += `${_strings[i + 1]}`;
      } else {
        str += `$${valueIdx++}${_strings[i + 1]}`;
      }
    }

    // Strip out undefined values
    return await sql.unsafe(
      str,
      _values.filter((it) => it !== undefined),
    );
  }
}

/**
 * Check if the passed in value is an object generated by 'query``'.
 *
 * @since 0.1.0
 *
 * @param {*} query
 * @returns {boolean}
 */
export function isQueryPart(query) {
  return (
    !isNil(query) &&
    Array.isArray(query?.strings) &&
    Array.isArray(query?.values)
  );
}

/**
 * Stringify a queryPart.
 * When interpolateParameters is true, we do a best effort in replacing the parameterized
 * query with the real params. If the result doesn't look right, please turn it off.
 *
 * @since 0.1.0
 *
 * @param {QueryPart} queryPart
 * @param {{ interpolateParameters?: boolean }} options
 * @returns {string|{ sql: string, params: *[] }}
 */
export function stringifyQueryPart(queryPart, { interpolateParameters } = {}) {
  if (!isQueryPart(queryPart)) {
    throw new Error(
      `'stringifyQueryPart' expects a query part produced by calling 'query\`\`'`,
    );
  }

  let sql = undefined;
  let params = undefined;
  queryPart.exec({
    unsafe(queryString, parameters) {
      sql = queryString.trim();
      params = parameters;
    },
  });

  if (!interpolateParameters) {
    return {
      sql,
      params,
    };
  }

  return sql.replace(/\$\d+/g, (match) => {
    const idx = parseInt(match.substring(1));
    const value = params[idx - 1];

    if (typeof value === "string") {
      return `'${value}'`;
    }
    return params[idx - 1];
  });
}

/**
 * Creates a transaction, executes the query, and rollback the transaction afterwards.
 * This is safe to use with insert, update and delete queries.
 *
 * By default returns text, but can also return json.
 * Note that explain output is highly depended on the current data and usage of the
 * tables.
 *
 * @since 0.1.0
 *
 * @param {Postgres} sql
 * @param {QueryPart} queryItem
 * @param {boolean} [jsonResult]=false
 * @returns {Promise<string|object>}
 */
export async function explainAnalyzeQuery(sql, queryItem, { jsonResult } = {}) {
  let result;

  try {
    await sql.begin(async (sql) => {
      if (jsonResult) {
        const intermediate = await query`EXPLAIN (ANALYZE, VERBOSE, BUFFERS, FORMAT JSON) ${queryItem}`.exec(
          sql,
        );
        result = intermediate[0];
      } else {
        const intermediate = await query`EXPLAIN (ANALYZE, VERBOSE, BUFFERS, FORMAT TEXT) ${queryItem}`.exec(
          sql,
        );

        result = intermediate.map((it) => it["QUERY PLAN"]).join("\n");
      }
      // Rollback the transaction
      throw new Error();
    });
  } catch {
    // Ignore
  }

  return result;
}
