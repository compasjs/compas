// Generated by @compas/code-gen

/**
 * @template T, E
 * @typedef {{ value: T, error?: never}|{ value?: never, error: E }} Either
 */

/**
 * @typedef {Record<string, any|undefined>} ValidatorErrorMap
 */

const isRecord = (v) => !!v && typeof v === "object" && !Array.isArray(v);

/**
 * @param {import("../common/types.js").QueryExpansionStoreFile|any} value
 * @returns {Either<import("../common/types.js").QueryExpansionStoreFile, ValidatorErrorMap>}
 */
export function validateQueryExpansionStoreFile(value) {
  /** @type {ValidatorErrorMap} */
  const errorMap = {};
  /** @type {any} */
  let result = undefined;

  if (value === null || value === undefined) {
    errorMap[`$`] = {
      key: "validator.undefined",
    };
  } else {
    if (!isRecord(value)) {
      errorMap[`$`] = {
        key: "validator.object",
        value: value,
        foundType: typeof value,
      };
    } else {
      /** @type {Set<string>} */
      const knownKeys0 = new Set([]);
      for (const key of Object.keys(value)) {
        if (
          !knownKeys0.has(key) &&
          value[key] !== null &&
          value[key] !== undefined
        ) {
          const expectedKeys = [...knownKeys0];
          const foundKeys = Object.keys(value);
          const unknownKeys = foundKeys.filter((it) => !knownKeys0.has(it));
          errorMap[`$`] = {
            key: "validator.keys",
            unknownKeys,
            expectedKeys,
            foundKeys,
          };
          break;
        }
      }
      result = {};
    }
  }
  if (Object.keys(errorMap).length > 0) {
    return { error: errorMap };
  }
  return { value: result };
}

/**
 * @param {import("../common/types.js").QueryExpansionStoreJob|any} value
 * @returns {Either<import("../common/types.js").QueryExpansionStoreJob, ValidatorErrorMap>}
 */
export function validateQueryExpansionStoreJob(value) {
  /** @type {ValidatorErrorMap} */
  const errorMap = {};
  /** @type {any} */
  let result = undefined;

  if (value === null || value === undefined) {
    errorMap[`$`] = {
      key: "validator.undefined",
    };
  } else {
    if (!isRecord(value)) {
      errorMap[`$`] = {
        key: "validator.object",
        value: value,
        foundType: typeof value,
      };
    } else {
      /** @type {Set<string>} */
      const knownKeys0 = new Set([]);
      for (const key of Object.keys(value)) {
        if (
          !knownKeys0.has(key) &&
          value[key] !== null &&
          value[key] !== undefined
        ) {
          const expectedKeys = [...knownKeys0];
          const foundKeys = Object.keys(value);
          const unknownKeys = foundKeys.filter((it) => !knownKeys0.has(it));
          errorMap[`$`] = {
            key: "validator.keys",
            unknownKeys,
            expectedKeys,
            foundKeys,
          };
          break;
        }
      }
      result = {};
    }
  }
  if (Object.keys(errorMap).length > 0) {
    return { error: errorMap };
  }
  return { value: result };
}

/**
 * @param {import("../common/types.js").QueryExpansionStoreSessionStore|any} value
 * @returns {Either<import("../common/types.js").QueryExpansionStoreSessionStore, ValidatorErrorMap>}
 */
export function validateQueryExpansionStoreSessionStore(value) {
  /** @type {ValidatorErrorMap} */
  const errorMap = {};
  /** @type {any} */
  let result = undefined;

  if (value === null || value === undefined) {
    errorMap[`$`] = {
      key: "validator.undefined",
    };
  } else {
    if (!isRecord(value)) {
      errorMap[`$`] = {
        key: "validator.object",
        value: value,
        foundType: typeof value,
      };
    } else {
      /** @type {Set<string>} */
      const knownKeys0 = new Set(["accessTokens"]);
      for (const key of Object.keys(value)) {
        if (
          !knownKeys0.has(key) &&
          value[key] !== null &&
          value[key] !== undefined
        ) {
          const expectedKeys = [...knownKeys0];
          const foundKeys = Object.keys(value);
          const unknownKeys = foundKeys.filter((it) => !knownKeys0.has(it));
          errorMap[`$`] = {
            key: "validator.keys",
            unknownKeys,
            expectedKeys,
            foundKeys,
          };
          break;
        }
      }
      result = { accessTokens: undefined };

      if (
        value["accessTokens"] === null ||
        value["accessTokens"] === undefined
      ) {
        result["accessTokens"] = undefined;
      } else {
        /** @type {ValidatorErrorMap} */
        const intermediateErrorMap2 = {};
        /** @type {Array<any>} */
        const intermediateResult2 = [];
        /** @type {any | Array<any>} */
        const intermediateValue2 = value["accessTokens"];

        if (!Array.isArray(intermediateValue2)) {
          errorMap[`$.accessTokens`] = {
            key: "validator.array",
            value: intermediateValue2,
          };
        } else {
          result["accessTokens"] = [];
          for (let i2 = 0; i2 < intermediateValue2.length; ++i2) {
            if (
              intermediateValue2[i2] === null ||
              intermediateValue2[i2] === undefined
            ) {
              intermediateErrorMap2[`$.${i2}`] = {
                key: "validator.undefined",
              };
            } else {
              intermediateResult2[i2] = intermediateValue2[i2];
            }
          }
        }
        if (Object.keys(intermediateErrorMap2).length) {
          for (const errorKey of Object.keys(intermediateErrorMap2)) {
            errorMap[`$.accessTokens${errorKey.substring(1)}`] =
              intermediateErrorMap2[errorKey];
          }
        } else {
          result["accessTokens"] = intermediateResult2;
        }
      }
    }
  }
  if (Object.keys(errorMap).length > 0) {
    return { error: errorMap };
  }
  return { value: result };
}

/**
 * @param {import("../common/types.js").QueryExpansionStoreSessionStoreToken|any} value
 * @returns {Either<import("../common/types.js").QueryExpansionStoreSessionStoreToken, ValidatorErrorMap>}
 */
export function validateQueryExpansionStoreSessionStoreToken(value) {
  /** @type {ValidatorErrorMap} */
  const errorMap = {};
  /** @type {any} */
  let result = undefined;

  if (value === null || value === undefined) {
    errorMap[`$`] = {
      key: "validator.undefined",
    };
  } else {
    if (!isRecord(value)) {
      errorMap[`$`] = {
        key: "validator.object",
        value: value,
        foundType: typeof value,
      };
    } else {
      /** @type {Set<string>} */
      const knownKeys0 = new Set(["refreshToken", "session", "accessToken"]);
      for (const key of Object.keys(value)) {
        if (
          !knownKeys0.has(key) &&
          value[key] !== null &&
          value[key] !== undefined
        ) {
          const expectedKeys = [...knownKeys0];
          const foundKeys = Object.keys(value);
          const unknownKeys = foundKeys.filter((it) => !knownKeys0.has(it));
          errorMap[`$`] = {
            key: "validator.keys",
            unknownKeys,
            expectedKeys,
            foundKeys,
          };
          break;
        }
      }
      result = {
        refreshToken: undefined,
        session: undefined,
        accessToken: undefined,
      };

      if (
        value["refreshToken"] === null ||
        value["refreshToken"] === undefined
      ) {
        result["refreshToken"] = undefined;
      } else {
        result["refreshToken"] = value["refreshToken"];
      }
      if (value["session"] === null || value["session"] === undefined) {
        errorMap[`$.session`] = {
          key: "validator.undefined",
        };
      } else {
        result["session"] = value["session"];
      }
      if (value["accessToken"] === null || value["accessToken"] === undefined) {
        result["accessToken"] = undefined;
      } else {
        result["accessToken"] = value["accessToken"];
      }
    }
  }
  if (Object.keys(errorMap).length > 0) {
    return { error: errorMap };
  }
  return { value: result };
}
