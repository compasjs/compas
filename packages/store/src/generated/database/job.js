// Generated by @compas/code-gen
/* eslint-disable no-unused-vars */

import { AppError, isNil, isPlainObject, isStaging } from "@compas/stdlib";
import { isQueryPart, query } from "@compas/store";
import {
  validateStoreJobOrderBy,
  validateStoreJobOrderBySpec,
  validateStoreJobQueryBuilder,
  validateStoreJobWhere,
} from "../store/validators.js";

const jobFieldSet = new Set([
  "id",
  "isComplete",
  "priority",
  "scheduledAt",
  "name",
  "data",
  "retryCount",
  "handlerTimeout",
  "createdAt",
  "updatedAt",
]);
/**
 * Get all fields for job
 *
 * @param {string} [tableName="j."]
 * @param {{ excludePrimaryKey?: boolean }} [options={}]
 * @returns {QueryPart}
 */
export function jobFields(tableName = "j.", options = {}) {
  if (tableName.length > 0 && !tableName.endsWith(".")) {
    tableName = `${tableName}.`;
  }
  if (options.excludePrimaryKey) {
    return query([
      `${tableName}"isComplete", ${tableName}"handlerTimeout", ${tableName}"priority", ${tableName}"retryCount", ${tableName}"name", ${tableName}"scheduledAt", ${tableName}"data", ${tableName}"createdAt", ${tableName}"updatedAt"`,
    ]);
  }
  return query([
    `${tableName}"id", ${tableName}"isComplete", ${tableName}"handlerTimeout", ${tableName}"priority", ${tableName}"retryCount", ${tableName}"name", ${tableName}"scheduledAt", ${tableName}"data", ${tableName}"createdAt", ${tableName}"updatedAt"`,
  ]);
}
/**
 * Build 'WHERE ' part for job
 *
 * @param {StoreJobWhere} [where={}]
 * @param {string} [tableName="j."]
 * @param {{ skipValidator?: boolean|undefined }} [options={}]
 * @returns {QueryPart}
 */
export function jobWhere(where = {}, tableName = "j.", options = {}) {
  if (tableName.length > 0 && !tableName.endsWith(".")) {
    tableName = `${tableName}.`;
  }
  if (!options.skipValidator) {
    where = validateStoreJobWhere(where, "$.jobWhere");
  }
  const strings = ["1 = 1"];
  /** @type {QueryPartArg[]} */
  const values = [undefined];
  if (!isNil(where.$raw) && isQueryPart(where.$raw)) {
    strings.push(" AND ");
    values.push(where.$raw);
  }
  if (Array.isArray(where.$or) && where.$or.length > 0) {
    strings.push(" AND ((");
    for (let i = 0; i < where.$or.length; i++) {
      values.push(jobWhere(where.$or[i], tableName));
      if (i === where.$or.length - 1) {
        strings.push("))");
        values.push(undefined);
      } else {
        strings.push(") OR (");
      }
    }
  }
  if (where.id !== undefined) {
    strings.push(` AND ${tableName}"id" = `);
    values.push(where.id);
  }
  if (where.idNotEqual !== undefined) {
    strings.push(` AND ${tableName}"id" != `);
    values.push(where.idNotEqual);
  }
  if (where.idIn !== undefined) {
    if (isQueryPart(where.idIn)) {
      strings.push(` AND ${tableName}"id" = ANY(`, ")");
      values.push(where.idIn, undefined);
    } else if (Array.isArray(where.idIn)) {
      strings.push(` AND ${tableName}"id" = ANY(ARRAY[`);
      for (let i = 0; i < where.idIn.length; ++i) {
        values.push(where.idIn[i]);
        if (i !== where.idIn.length - 1) {
          strings.push(", ");
        }
      }
      strings.push("]::int[])");
      if (where.idIn.length === 0) {
        values.push(undefined);
      }
      values.push(undefined);
    }
  }
  if (where.idNotIn !== undefined) {
    if (isQueryPart(where.idNotIn)) {
      strings.push(` AND ${tableName}"id" != ANY(`, ")");
      values.push(where.idNotIn, undefined);
    } else if (Array.isArray(where.idNotIn)) {
      strings.push(` AND NOT (${tableName}"id" = ANY(ARRAY[`);
      for (let i = 0; i < where.idNotIn.length; ++i) {
        values.push(where.idNotIn[i]);
        if (i !== where.idNotIn.length - 1) {
          strings.push(", ");
        }
      }
      strings.push("]::int[]))");
      if (where.idNotIn.length === 0) {
        values.push(undefined);
      }
      values.push(undefined);
    }
  }
  if (where.idGreaterThan !== undefined) {
    strings.push(` AND ${tableName}"id" > `);
    values.push(where.idGreaterThan);
  }
  if (where.idLowerThan !== undefined) {
    strings.push(` AND ${tableName}"id" < `);
    values.push(where.idLowerThan);
  }
  if (where.isComplete !== undefined) {
    strings.push(` AND ${tableName}"isComplete" = `);
    values.push(where.isComplete);
  }
  if (where.isCompleteIsNull !== undefined) {
    strings.push(` AND ${tableName}"isComplete" IS NULL `);
    values.push(undefined);
  }
  if (where.isCompleteIsNotNull !== undefined) {
    strings.push(` AND ${tableName}"isComplete" IS NOT NULL `);
    values.push(undefined);
  }
  if (where.name !== undefined) {
    strings.push(` AND ${tableName}"name" = `);
    values.push(where.name);
  }
  if (where.nameNotEqual !== undefined) {
    strings.push(` AND ${tableName}"name" != `);
    values.push(where.nameNotEqual);
  }
  if (where.nameIn !== undefined) {
    if (isQueryPart(where.nameIn)) {
      strings.push(` AND ${tableName}"name" = ANY(`, ")");
      values.push(where.nameIn, undefined);
    } else if (Array.isArray(where.nameIn)) {
      strings.push(` AND ${tableName}"name" = ANY(ARRAY[`);
      for (let i = 0; i < where.nameIn.length; ++i) {
        values.push(where.nameIn[i]);
        if (i !== where.nameIn.length - 1) {
          strings.push(", ");
        }
      }
      strings.push("]::varchar[])");
      if (where.nameIn.length === 0) {
        values.push(undefined);
      }
      values.push(undefined);
    }
  }
  if (where.nameNotIn !== undefined) {
    if (isQueryPart(where.nameNotIn)) {
      strings.push(` AND ${tableName}"name" != ANY(`, ")");
      values.push(where.nameNotIn, undefined);
    } else if (Array.isArray(where.nameNotIn)) {
      strings.push(` AND NOT (${tableName}"name" = ANY(ARRAY[`);
      for (let i = 0; i < where.nameNotIn.length; ++i) {
        values.push(where.nameNotIn[i]);
        if (i !== where.nameNotIn.length - 1) {
          strings.push(", ");
        }
      }
      strings.push("]::varchar[]))");
      if (where.nameNotIn.length === 0) {
        values.push(undefined);
      }
      values.push(undefined);
    }
  }
  if (where.nameLike !== undefined) {
    strings.push(` AND ${tableName}"name" LIKE `);
    values.push(`%${where.nameLike}%`);
  }
  if (where.nameILike !== undefined) {
    strings.push(` AND ${tableName}"name" ILIKE `);
    values.push(`%${where.nameILike}%`);
  }
  if (where.nameNotLike !== undefined) {
    strings.push(` AND ${tableName}"name" NOT LIKE `);
    values.push(`%${where.nameNotLike}%`);
  }
  if (where.scheduledAt !== undefined) {
    strings.push(` AND ${tableName}"scheduledAt" = `);
    values.push(where.scheduledAt);
  }
  if (where.scheduledAtNotEqual !== undefined) {
    strings.push(` AND ${tableName}"scheduledAt" != `);
    values.push(where.scheduledAtNotEqual);
  }
  if (where.scheduledAtIn !== undefined) {
    if (isQueryPart(where.scheduledAtIn)) {
      strings.push(` AND ${tableName}"scheduledAt" = ANY(`, ")");
      values.push(where.scheduledAtIn, undefined);
    } else if (Array.isArray(where.scheduledAtIn)) {
      strings.push(` AND ${tableName}"scheduledAt" = ANY(ARRAY[`);
      for (let i = 0; i < where.scheduledAtIn.length; ++i) {
        values.push(where.scheduledAtIn[i]);
        if (i !== where.scheduledAtIn.length - 1) {
          strings.push(", ");
        }
      }
      strings.push("]::timestamptz[])");
      if (where.scheduledAtIn.length === 0) {
        values.push(undefined);
      }
      values.push(undefined);
    }
  }
  if (where.scheduledAtNotIn !== undefined) {
    if (isQueryPart(where.scheduledAtNotIn)) {
      strings.push(` AND ${tableName}"scheduledAt" != ANY(`, ")");
      values.push(where.scheduledAtNotIn, undefined);
    } else if (Array.isArray(where.scheduledAtNotIn)) {
      strings.push(` AND NOT (${tableName}"scheduledAt" = ANY(ARRAY[`);
      for (let i = 0; i < where.scheduledAtNotIn.length; ++i) {
        values.push(where.scheduledAtNotIn[i]);
        if (i !== where.scheduledAtNotIn.length - 1) {
          strings.push(", ");
        }
      }
      strings.push("]::timestamptz[]))");
      if (where.scheduledAtNotIn.length === 0) {
        values.push(undefined);
      }
      values.push(undefined);
    }
  }
  if (where.scheduledAtGreaterThan !== undefined) {
    strings.push(` AND ${tableName}"scheduledAt" > `);
    values.push(where.scheduledAtGreaterThan);
  }
  if (where.scheduledAtLowerThan !== undefined) {
    strings.push(` AND ${tableName}"scheduledAt" < `);
    values.push(where.scheduledAtLowerThan);
  }
  if (where.scheduledAtIsNull !== undefined) {
    strings.push(` AND ${tableName}"scheduledAt" IS NULL `);
    values.push(undefined);
  }
  if (where.scheduledAtIsNotNull !== undefined) {
    strings.push(` AND ${tableName}"scheduledAt" IS NOT NULL `);
    values.push(undefined);
  }
  if (where.createdAt !== undefined) {
    strings.push(` AND ${tableName}"createdAt" = `);
    values.push(where.createdAt);
  }
  if (where.createdAtNotEqual !== undefined) {
    strings.push(` AND ${tableName}"createdAt" != `);
    values.push(where.createdAtNotEqual);
  }
  if (where.createdAtIn !== undefined) {
    if (isQueryPart(where.createdAtIn)) {
      strings.push(` AND ${tableName}"createdAt" = ANY(`, ")");
      values.push(where.createdAtIn, undefined);
    } else if (Array.isArray(where.createdAtIn)) {
      strings.push(` AND ${tableName}"createdAt" = ANY(ARRAY[`);
      for (let i = 0; i < where.createdAtIn.length; ++i) {
        values.push(where.createdAtIn[i]);
        if (i !== where.createdAtIn.length - 1) {
          strings.push(", ");
        }
      }
      strings.push("]::timestamptz[])");
      if (where.createdAtIn.length === 0) {
        values.push(undefined);
      }
      values.push(undefined);
    }
  }
  if (where.createdAtNotIn !== undefined) {
    if (isQueryPart(where.createdAtNotIn)) {
      strings.push(` AND ${tableName}"createdAt" != ANY(`, ")");
      values.push(where.createdAtNotIn, undefined);
    } else if (Array.isArray(where.createdAtNotIn)) {
      strings.push(` AND NOT (${tableName}"createdAt" = ANY(ARRAY[`);
      for (let i = 0; i < where.createdAtNotIn.length; ++i) {
        values.push(where.createdAtNotIn[i]);
        if (i !== where.createdAtNotIn.length - 1) {
          strings.push(", ");
        }
      }
      strings.push("]::timestamptz[]))");
      if (where.createdAtNotIn.length === 0) {
        values.push(undefined);
      }
      values.push(undefined);
    }
  }
  if (where.createdAtGreaterThan !== undefined) {
    strings.push(` AND ${tableName}"createdAt" > `);
    values.push(where.createdAtGreaterThan);
  }
  if (where.createdAtLowerThan !== undefined) {
    strings.push(` AND ${tableName}"createdAt" < `);
    values.push(where.createdAtLowerThan);
  }
  if (where.createdAtIsNull !== undefined) {
    strings.push(` AND ${tableName}"createdAt" IS NULL `);
    values.push(undefined);
  }
  if (where.createdAtIsNotNull !== undefined) {
    strings.push(` AND ${tableName}"createdAt" IS NOT NULL `);
    values.push(undefined);
  }
  if (where.updatedAt !== undefined) {
    strings.push(` AND ${tableName}"updatedAt" = `);
    values.push(where.updatedAt);
  }
  if (where.updatedAtNotEqual !== undefined) {
    strings.push(` AND ${tableName}"updatedAt" != `);
    values.push(where.updatedAtNotEqual);
  }
  if (where.updatedAtIn !== undefined) {
    if (isQueryPart(where.updatedAtIn)) {
      strings.push(` AND ${tableName}"updatedAt" = ANY(`, ")");
      values.push(where.updatedAtIn, undefined);
    } else if (Array.isArray(where.updatedAtIn)) {
      strings.push(` AND ${tableName}"updatedAt" = ANY(ARRAY[`);
      for (let i = 0; i < where.updatedAtIn.length; ++i) {
        values.push(where.updatedAtIn[i]);
        if (i !== where.updatedAtIn.length - 1) {
          strings.push(", ");
        }
      }
      strings.push("]::timestamptz[])");
      if (where.updatedAtIn.length === 0) {
        values.push(undefined);
      }
      values.push(undefined);
    }
  }
  if (where.updatedAtNotIn !== undefined) {
    if (isQueryPart(where.updatedAtNotIn)) {
      strings.push(` AND ${tableName}"updatedAt" != ANY(`, ")");
      values.push(where.updatedAtNotIn, undefined);
    } else if (Array.isArray(where.updatedAtNotIn)) {
      strings.push(` AND NOT (${tableName}"updatedAt" = ANY(ARRAY[`);
      for (let i = 0; i < where.updatedAtNotIn.length; ++i) {
        values.push(where.updatedAtNotIn[i]);
        if (i !== where.updatedAtNotIn.length - 1) {
          strings.push(", ");
        }
      }
      strings.push("]::timestamptz[]))");
      if (where.updatedAtNotIn.length === 0) {
        values.push(undefined);
      }
      values.push(undefined);
    }
  }
  if (where.updatedAtGreaterThan !== undefined) {
    strings.push(` AND ${tableName}"updatedAt" > `);
    values.push(where.updatedAtGreaterThan);
  }
  if (where.updatedAtLowerThan !== undefined) {
    strings.push(` AND ${tableName}"updatedAt" < `);
    values.push(where.updatedAtLowerThan);
  }
  if (where.updatedAtIsNull !== undefined) {
    strings.push(` AND ${tableName}"updatedAt" IS NULL `);
    values.push(undefined);
  }
  if (where.updatedAtIsNotNull !== undefined) {
    strings.push(` AND ${tableName}"updatedAt" IS NOT NULL `);
    values.push(undefined);
  }
  strings.push("");
  return query(strings, ...values);
}
/**
 * Build 'ORDER BY ' part for job
 *
 * @param {StoreJobOrderBy} [orderBy=["createdAt", "updatedAt", "id"]]
 * @param {StoreJobOrderBySpec} [orderBySpec={}]
 * @param {string} [tableName="j."]
 * @param {{ skipValidator?: boolean|undefined }} [options={}]
 * @returns {QueryPart}
 */
export function jobOrderBy(
  orderBy = ["createdAt", "updatedAt", "id"],
  orderBySpec = {},
  tableName = "j.",
  options = {},
) {
  if (tableName.length > 0 && !tableName.endsWith(".")) {
    tableName = `${tableName}.`;
  }
  if (!options.skipValidator) {
    orderBy = validateStoreJobOrderBy(orderBy, "$.StoreJobOrderBy");
    orderBySpec = validateStoreJobOrderBySpec(
      orderBySpec,
      "$.StoreJobOrderBySpec",
    );
  }
  if (isQueryPart(orderBy)) {
    return orderBy;
  }
  const strings = [];
  const values = [];
  let i = 0;
  for (const value of orderBy) {
    if (i !== 0) {
      strings.push(", ");
      values.push(undefined);
    }
    i++;
    strings.push(`${tableName}"${value}" `, orderBySpec[value] ?? "ASC");
    values.push(undefined, undefined);
  }
  strings.push("");
  return query(strings, ...values);
}
/**
 * Build 'VALUES ' part for job
 *
 * @param {StoreJobInsertPartial|StoreJobInsertPartial[]} insert
 * @param {{ includePrimaryKey?: boolean }} [options={}]
 * @returns {QueryPart}
 */
export function jobInsertValues(insert, options = {}) {
  if (!Array.isArray(insert)) {
    insert = [insert];
  }
  const q = query``;
  for (let i = 0; i < insert.length; ++i) {
    const it = insert[i];
    checkFieldsInSet("job", "insert", jobFieldSet, it);
    q.append(query`(
${options?.includePrimaryKey ? query`${it.id}, ` : undefined}
${it.isComplete ?? false}, ${it.handlerTimeout ?? null}, ${it.priority ?? 0}, ${
      it.retryCount ?? 0
    }, ${it.name ?? null}, ${it.scheduledAt ?? new Date()}, ${JSON.stringify(
      it.data ?? {},
    )}, ${it.createdAt ?? new Date()}, ${it.updatedAt ?? new Date()}
)`);
    if (i !== insert.length - 1) {
      q.append(query`, `);
    }
  }
  return q;
}
/**
 * Build 'SET ' part for job
 *
 * @param {StoreJobUpdatePartial} update
 * @returns {QueryPart}
 */
export function jobUpdateSet(update) {
  const strings = [];
  const values = [];
  checkFieldsInSet("job", "update", jobFieldSet, update);
  if (update.isComplete !== undefined) {
    strings.push(`, "isComplete" = `);
    values.push(update.isComplete ?? false);
  }
  if (update.handlerTimeout !== undefined) {
    strings.push(`, "handlerTimeout" = `);
    values.push(update.handlerTimeout ?? null);
  }
  if (update.priority !== undefined) {
    strings.push(`, "priority" = `);
    values.push(update.priority ?? 0);
  }
  if (update.retryCount !== undefined) {
    strings.push(`, "retryCount" = `);
    values.push(update.retryCount ?? 0);
  }
  if (update.name !== undefined) {
    strings.push(`, "name" = `);
    values.push(update.name ?? null);
  }
  if (update.scheduledAt !== undefined) {
    strings.push(`, "scheduledAt" = `);
    values.push(update.scheduledAt ?? new Date());
  }
  if (update.data !== undefined) {
    strings.push(`, "data" = `);
    values.push(JSON.stringify(update.data ?? {}));
  }
  if (update.createdAt !== undefined) {
    strings.push(`, "createdAt" = `);
    values.push(update.createdAt ?? new Date());
  }
  strings.push(`, "updatedAt" = `);
  values.push(new Date());
  // Remove the comma suffix
  strings[0] = strings[0].substring(2);
  strings.push("");
  return query(strings, ...values);
}
/**
 * @param {string} entity
 * @param {string} subType
 * @param {Set} set
 * @param {*} value
 */
function checkFieldsInSet(entity, subType, set, value) {
  if (isStaging()) {
    for (const key of Object.keys(value)) {
      if (!set.has(key) && value[key] !== undefined) {
        throw new AppError(`query.${entity}.${subType}Fields`, 500, {
          extraKey: key,
          knownKeys: [...set],
        });
      }
    }
  }
}
/**
 * @param {Postgres} sql
 * @param {StoreJobWhere} [where]
 * @returns {Promise<number>}
 */
async function jobCount(sql, where) {
  const [result] = await query`
SELECT COUNT(j."id") as "countResult"
FROM "job" j
WHERE ${jobWhere(where)}
`.exec(sql);
  return Number(result?.countResult ?? "0");
}
/**
 * @param {Postgres} sql
 * @param {StoreJobWhere} [where={}]
 * @returns {Promise<void>}
 */
async function jobDelete(sql, where = {}) {
  return await query`
DELETE FROM "job" j
WHERE ${jobWhere(where)}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreJobInsertPartial|(StoreJobInsertPartial[])} insert
 * @param {{ withPrimaryKey?: boolean }} [options={}]
 * @returns {Promise<StoreJob[]>}
 */
async function jobInsert(sql, insert, options = {}) {
  if (insert === undefined || (Array.isArray(insert) && insert.length === 0)) {
    return [];
  }
  options.withPrimaryKey = options.withPrimaryKey ?? false;
  const result = await query`
INSERT INTO "job" (${jobFields("", {
    excludePrimaryKey: !options.withPrimaryKey,
  })})
VALUES ${jobInsertValues(insert, { includePrimaryKey: options.withPrimaryKey })}
RETURNING ${jobFields("")}
`.exec(sql);
  transformJob(result);
  return result;
}
/**
 * @param {Postgres} sql
 * @param {StoreJobInsertPartial|(StoreJobInsertPartial[])} insert
 * @param {{}} [options={}]
 * @returns {Promise<StoreJob[]>}
 */
async function jobUpsertOnId(sql, insert, options = {}) {
  if (insert === undefined || (Array.isArray(insert) && insert.length === 0)) {
    return [];
  }
  const fieldString = [...jobFieldSet]
    .filter((it) => it !== "id" && it !== "createdAt")
    .map(
      (column) =>
        `"${column}" = COALESCE(EXCLUDED."${column}", "job"."${column}")`,
    )
    .join(",");
  const result = await query`
INSERT INTO "job" (${jobFields("", { excludePrimaryKey: false })})
VALUES ${jobInsertValues(insert, { includePrimaryKey: true })}
ON CONFLICT ("id") DO UPDATE SET ${query([fieldString])}
RETURNING ${jobFields("")}
`.exec(sql);
  transformJob(result);
  return result;
}
/**
 * @param {Postgres} sql
 * @param {StoreJobUpdatePartial} update
 * @param {StoreJobWhere} [where={}]
 * @returns {Promise<StoreJob[]>}
 */
async function jobUpdate(sql, update, where = {}) {
  const result = await query`
UPDATE "job" j
SET ${jobUpdateSet(update)}
WHERE ${jobWhere(where)}
RETURNING ${jobFields()}
`.exec(sql);
  transformJob(result);
  return result;
}
export const jobQueries = {
  jobCount,
  jobDelete,
  jobInsert,
  jobUpsertOnId,
  jobUpdate,
};
/**
 * @param {StoreJobQueryBuilder & StoreJobQueryTraverser} builder
 * @param {QueryPart|undefined} [wherePartial]
 * @returns {QueryPart}
 */
export function internalQueryJob(builder, wherePartial) {
  const joinQb = query``;
  return query`
FROM "job" j
${joinQb}
WHERE ${jobWhere(builder.where, "j.", { skipValidator: true })} ${wherePartial}
`;
}
/**
 * Query Builder for job
 * Note that nested limit and offset don't work yet.
 *
 * @param {StoreJobQueryBuilder} [builder={}]
 * @returns {{
 *  then: () => void,
 *  exec: (sql: Postgres) => Promise<QueryResultStoreJob[]>,
 *  execRaw: (sql: Postgres) => Promise<any[]>,
 *  queryPart: QueryPart<any>,
 * }}
 */
export function queryJob(builder = {}) {
  const joinedKeys = [];
  validateStoreJobQueryBuilder(builder, "$.jobBuilder");
  const qb = query`
SELECT to_jsonb(j.*) || jsonb_build_object(${query([
    joinedKeys.join(","),
  ])}) as "result"
${internalQueryJob(builder ?? {})}
ORDER BY ${jobOrderBy(builder.orderBy, builder.orderBySpec)}
`;
  if (!isNil(builder.offset)) {
    qb.append(query`OFFSET ${builder.offset}`);
  }
  if (!isNil(builder.limit)) {
    qb.append(query`FETCH NEXT ${builder.limit} ROWS ONLY`);
  }
  return {
    then: () => {
      throw AppError.serverError({
        message:
          "Awaited 'queryJob' directly. Please use '.exec' or '.execRaw'.",
      });
    },
    execRaw: async (sql) => await qb.exec(sql),
    exec: async (sql) => {
      const result = await qb.exec(sql);
      transformJob(result, builder);
      return result;
    },
    get queryPart() {
      return qb;
    },
  };
}
/**
 * NOTE: At the moment only intended for internal use by the generated queries!
 *
 * Transform results from the query builder that adhere to the known structure
 * of 'job' and its relations.
 *
 * @param {any[]} values
 * @param {StoreJobQueryBuilder} [builder={}]
 */
export function transformJob(values, builder = {}) {
  for (let i = 0; i < values.length; ++i) {
    let value = values[i];
    if (isPlainObject(value.result) && Object.keys(value).length === 1) {
      values[i] = value.result;
      value = value.result;
    }
    value.handlerTimeout = value.handlerTimeout ?? undefined;
    if (typeof value.scheduledAt === "string") {
      value.scheduledAt = new Date(value.scheduledAt);
    }
    if (typeof value.createdAt === "string") {
      value.createdAt = new Date(value.createdAt);
    }
    if (typeof value.updatedAt === "string") {
      value.updatedAt = new Date(value.updatedAt);
    }
  }
}
