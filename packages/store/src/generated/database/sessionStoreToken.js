// Generated by @compas/code-gen
/* eslint-disable no-unused-vars */

import { AppError, isNil, isPlainObject, isStaging } from "@compas/stdlib";
import { generatedWhereBuilderHelper, isQueryPart, query } from "@compas/store";
import {
  validateStoreSessionStoreTokenOrderBy,
  validateStoreSessionStoreTokenOrderBySpec,
  validateStoreSessionStoreTokenQueryBuilder,
  validateStoreSessionStoreTokenWhere,
} from "../store/validators.js";
import {
  internalQuerySessionStore,
  sessionStoreOrderBy,
  sessionStoreWhere,
  transformSessionStore,
} from "./sessionStore.js";

const sessionStoreTokenFieldSet = new Set([
  "expiresAt",
  "revokedAt",
  "id",
  "session",
  "refreshToken",
]);
/**
 * Get all fields for sessionStoreToken
 *
 * @param {string} [tableName="sst."]
 * @param {{ excludePrimaryKey?: boolean }} [options={}]
 * @returns {QueryPart}
 */
export function sessionStoreTokenFields(tableName = "sst.", options = {}) {
  if (tableName.length > 0 && !tableName.endsWith(".")) {
    tableName = `${tableName}.`;
  }
  if (options.excludePrimaryKey) {
    return query([
      `${tableName}"session", ${tableName}"expiresAt", ${tableName}"refreshToken", ${tableName}"revokedAt"`,
    ]);
  }
  return query([
    `${tableName}"id", ${tableName}"session", ${tableName}"expiresAt", ${tableName}"refreshToken", ${tableName}"revokedAt"`,
  ]);
}
/** @type {any} */
export const sessionStoreTokenWhereSpec = {
  fieldSpecification: [
    {
      tableKey: "id",
      keyType: "uuid",
      matchers: [
        { matcherKey: "id", matcherType: "equal" },
        { matcherKey: "idNotEqual", matcherType: "notEqual" },
        { matcherKey: "idIn", matcherType: "in" },
        { matcherKey: "idNotIn", matcherType: "notIn" },
      ],
    },
    {
      tableKey: "session",
      keyType: "uuid",
      matchers: [
        { matcherKey: "session", matcherType: "equal" },
        { matcherKey: "sessionNotEqual", matcherType: "notEqual" },
        { matcherKey: "sessionIn", matcherType: "in" },
        { matcherKey: "sessionNotIn", matcherType: "notIn" },
      ],
    },
    {
      tableKey: "expiresAt",
      keyType: "timestamptz",
      matchers: [
        { matcherKey: "expiresAt", matcherType: "equal" },
        { matcherKey: "expiresAtNotEqual", matcherType: "notEqual" },
        { matcherKey: "expiresAtIn", matcherType: "in" },
        { matcherKey: "expiresAtNotIn", matcherType: "notIn" },
        { matcherKey: "expiresAtGreaterThan", matcherType: "greaterThan" },
        { matcherKey: "expiresAtLowerThan", matcherType: "lowerThan" },
      ],
    },
    {
      tableKey: "refreshToken",
      keyType: "uuid",
      matchers: [
        { matcherKey: "refreshToken", matcherType: "equal" },
        { matcherKey: "refreshTokenNotEqual", matcherType: "notEqual" },
        { matcherKey: "refreshTokenIn", matcherType: "in" },
        { matcherKey: "refreshTokenNotIn", matcherType: "notIn" },
        { matcherKey: "refreshTokenIsNull", matcherType: "isNull" },
        { matcherKey: "refreshTokenIsNotNull", matcherType: "isNotNull" },
      ],
    },
    {
      tableKey: "revokedAt",
      keyType: "timestamptz",
      matchers: [
        { matcherKey: "revokedAt", matcherType: "equal" },
        { matcherKey: "revokedAtNotEqual", matcherType: "notEqual" },
        { matcherKey: "revokedAtIn", matcherType: "in" },
        { matcherKey: "revokedAtNotIn", matcherType: "notIn" },
        { matcherKey: "revokedAtGreaterThan", matcherType: "greaterThan" },
        { matcherKey: "revokedAtLowerThan", matcherType: "lowerThan" },
        { matcherKey: "revokedAtIsNull", matcherType: "isNull" },
        { matcherKey: "revokedAtIsNotNull", matcherType: "isNotNull" },
      ],
    },
    {
      tableKey: "accessToken",
      keyType: "undefined",
      matchers: [
        {
          matcherKey: "accessTokenExists",
          matcherType: "exists",
          relation: {
            entityName: "sessionStoreToken",
            shortName: "sst2",
            entityKey: "refreshToken",
            referencedKey: "id",
            where: "self",
          },
        },
        {
          matcherKey: "accessTokenNotExists",
          matcherType: "notExists",
          relation: {
            entityName: "sessionStoreToken",
            shortName: "sst2",
            entityKey: "refreshToken",
            referencedKey: "id",
            where: "self",
          },
        },
      ],
    },
  ],
};
/**
 * Build 'WHERE ' part for sessionStoreToken
 *
 * @param {StoreSessionStoreTokenWhere} [where={}]
 * @param {string} [tableName="sst."]
 * @param {{ skipValidator?: boolean|undefined }} [options={}]
 * @returns {QueryPart}
 */
export function sessionStoreTokenWhere(
  where = {},
  tableName = "sst.",
  options = {},
) {
  if (tableName.length > 0 && !tableName.endsWith(".")) {
    tableName = `${tableName}.`;
  }
  if (!options.skipValidator) {
    const whereValidated = validateStoreSessionStoreTokenWhere(
      where,
      "$.sessionStoreTokenWhere",
    );
    if (whereValidated.error) {
      throw whereValidated.error;
    }
    where = whereValidated.value;
  }
  return generatedWhereBuilderHelper(
    sessionStoreTokenWhereSpec,
    where,
    tableName,
  );
}
/**
 * Build 'ORDER BY ' part for sessionStoreToken
 *
 * @param {StoreSessionStoreTokenOrderBy} [orderBy=["id"]]
 * @param {StoreSessionStoreTokenOrderBySpec} [orderBySpec={}]
 * @param {string} [tableName="sst."]
 * @param {{ skipValidator?: boolean|undefined }} [options={}]
 * @returns {QueryPart}
 */
export function sessionStoreTokenOrderBy(
  orderBy = ["id"],
  orderBySpec = {},
  tableName = "sst.",
  options = {},
) {
  if (tableName.length > 0 && !tableName.endsWith(".")) {
    tableName = `${tableName}.`;
  }
  if (!options.skipValidator) {
    const orderByValidated = validateStoreSessionStoreTokenOrderBy(
      orderBy,
      "$.StoreSessionStoreTokenOrderBy",
    );
    if (orderByValidated.error) {
      throw orderByValidated.error;
    }
    orderBy = orderByValidated.value;
    const orderBySpecValidated = validateStoreSessionStoreTokenOrderBySpec(
      orderBySpec,
      "$.StoreSessionStoreTokenOrderBySpec",
    );
    if (orderBySpecValidated.error) {
      throw orderBySpecValidated.error;
    }
    orderBySpec = orderBySpecValidated.value;
  }
  if (isQueryPart(orderBy)) {
    return orderBy;
  }
  const strings = [];
  const values = [];
  let i = 0;
  for (const value of orderBy) {
    if (i !== 0) {
      strings.push(", ");
      values.push(undefined);
    }
    i++;
    strings.push(`${tableName}"${value}" `, orderBySpec[value] ?? "ASC");
    values.push(undefined, undefined);
  }
  strings.push("");
  return query(strings, ...values);
}
/**
 * Build 'VALUES ' part for sessionStoreToken
 *
 * @param {StoreSessionStoreTokenInsertPartial|StoreSessionStoreTokenInsertPartial[]} insert
 * @param {{ includePrimaryKey?: boolean }} [options={}]
 * @returns {QueryPart}
 */
export function sessionStoreTokenInsertValues(insert, options = {}) {
  if (!Array.isArray(insert)) {
    insert = [insert];
  }
  const str = [];
  const args = [];
  for (let i = 0; i < insert.length; ++i) {
    const it = insert[i];
    checkFieldsInSet(
      "sessionStoreToken",
      "insert",
      sessionStoreTokenFieldSet,
      it,
    );
    str.push("(");
    if (options?.includePrimaryKey) {
      args.push(it.id);
      str.push(", ");
    }
    args.push(it.session ?? null);
    str.push(", ");
    args.push(it.expiresAt ?? null);
    str.push(", ");
    args.push(it.refreshToken ?? null);
    str.push(", ");
    args.push(it.revokedAt ?? null);
    str.push(", ");
    // Fixup last comma & add undefined arg so strings are concatted correctly
    const lastStrIdx = str.length - 1;
    str[lastStrIdx] = str[lastStrIdx].substring(0, str[lastStrIdx].length - 2);
    args.push(undefined);
    str.push(")");
    args.push(undefined);
    if (i !== insert.length - 1) {
      args.push(undefined);
      str.push(",");
    }
  }
  return query(str, ...args);
}
/**
 * Build 'SET ' part for sessionStoreToken
 *
 * @param {StoreSessionStoreTokenUpdatePartial} update
 * @returns {QueryPart}
 */
export function sessionStoreTokenUpdateSet(update) {
  const strings = [];
  const values = [];
  checkFieldsInSet(
    "sessionStoreToken",
    "update",
    sessionStoreTokenFieldSet,
    update,
  );
  if (update.session !== undefined) {
    strings.push(`, "session" = `);
    values.push(update.session ?? null);
  }
  if (update.expiresAt !== undefined) {
    strings.push(`, "expiresAt" = `);
    values.push(update.expiresAt ?? null);
  }
  if (update.refreshToken !== undefined) {
    strings.push(`, "refreshToken" = `);
    values.push(update.refreshToken ?? null);
  }
  if (update.revokedAt !== undefined) {
    strings.push(`, "revokedAt" = `);
    values.push(update.revokedAt ?? null);
  }
  // Remove the comma suffix
  if (strings.length === 0) {
    throw AppError.validationError(
      "sessionStoreToken.updateSet.emptyUpdateStatement",
    );
  }
  strings[0] = strings[0].substring(2);
  strings.push("");
  return query(strings, ...values);
}
/**
 * @param {string} entity
 * @param {string} subType
 * @param {Set} set
 * @param {*} value
 */
function checkFieldsInSet(entity, subType, set, value) {
  if (isStaging()) {
    for (const key of Object.keys(value)) {
      if (!set.has(key) && value[key] !== undefined) {
        throw new AppError(`query.${entity}.${subType}Fields`, 500, {
          extraKey: key,
          knownKeys: [...set],
        });
      }
    }
  }
}
/**
 * @param {Postgres} sql
 * @param {StoreSessionStoreTokenWhere} [where]
 * @returns {Promise<number>}
 */
async function sessionStoreTokenCount(sql, where) {
  const [result] = await query`
SELECT COUNT(sst."id") as "countResult"
FROM "sessionStoreToken" sst
WHERE ${sessionStoreTokenWhere(where)}
`.exec(sql);
  return Number(result?.countResult ?? "0");
}
/**
 * @param {Postgres} sql
 * @param {StoreSessionStoreTokenWhere} [where={}]
 * @returns {Promise<void>}
 */
async function sessionStoreTokenDelete(sql, where = {}) {
  return await query`
DELETE FROM "sessionStoreToken" sst
WHERE ${sessionStoreTokenWhere(where)}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreSessionStoreTokenInsertPartial|(StoreSessionStoreTokenInsertPartial[])} insert
 * @param {{ withPrimaryKey?: boolean }} [options={}]
 * @returns {Promise<StoreSessionStoreToken[]>}
 */
async function sessionStoreTokenInsert(sql, insert, options = {}) {
  if (insert === undefined || (Array.isArray(insert) && insert.length === 0)) {
    return [];
  }
  options.withPrimaryKey = options.withPrimaryKey ?? false;
  const result = await query`
INSERT INTO "sessionStoreToken" (${sessionStoreTokenFields("", {
    excludePrimaryKey: !options.withPrimaryKey,
  })})
VALUES ${sessionStoreTokenInsertValues(insert, {
    includePrimaryKey: options.withPrimaryKey,
  })}
RETURNING ${sessionStoreTokenFields("")}
`.exec(sql);
  transformSessionStoreToken(result);
  return result;
}
/**
 * @param {Postgres} sql
 * @param {StoreSessionStoreTokenInsertPartial|(StoreSessionStoreTokenInsertPartial[])} insert
 * @param {{}} [options={}]
 * @returns {Promise<StoreSessionStoreToken[]>}
 */
async function sessionStoreTokenUpsertOnId(sql, insert, options = {}) {
  if (insert === undefined || (Array.isArray(insert) && insert.length === 0)) {
    return [];
  }
  const fieldString = [...sessionStoreTokenFieldSet]
    .filter((it) => it !== "id" && it !== "createdAt")
    .map(
      (column) =>
        `"${column}" = COALESCE(EXCLUDED."${column}", "sessionStoreToken"."${column}")`,
    )
    .join(",");
  const result = await query`
INSERT INTO "sessionStoreToken" (${sessionStoreTokenFields("", {
    excludePrimaryKey: false,
  })})
VALUES ${sessionStoreTokenInsertValues(insert, { includePrimaryKey: true })}
ON CONFLICT ("id") DO UPDATE SET ${query([fieldString])}
RETURNING ${sessionStoreTokenFields("")}
`.exec(sql);
  transformSessionStoreToken(result);
  return result;
}
/**
 * @param {Postgres} sql
 * @param {StoreSessionStoreTokenUpdatePartial} update
 * @param {StoreSessionStoreTokenWhere} [where={}]
 * @returns {Promise<StoreSessionStoreToken[]>}
 */
async function sessionStoreTokenUpdate(sql, update, where = {}) {
  const result = await query`
UPDATE "sessionStoreToken" sst
SET ${sessionStoreTokenUpdateSet(update)}
WHERE ${sessionStoreTokenWhere(where)}
RETURNING ${sessionStoreTokenFields()}
`.exec(sql);
  transformSessionStoreToken(result);
  return result;
}
export const sessionStoreTokenQueries = {
  sessionStoreTokenCount,
  sessionStoreTokenDelete,
  sessionStoreTokenInsert,
  sessionStoreTokenUpsertOnId,
  sessionStoreTokenUpdate,
};
/**
 * @param {StoreSessionStoreTokenQueryBuilder & StoreSessionStoreTokenQueryTraverser} builder
 * @param {QueryPart|undefined} [wherePartial]
 * @returns {QueryPart}
 */
export function internalQuerySessionStoreToken2(builder, wherePartial) {
  const joinQb = query``;
  if (builder.viaSession) {
    builder.where = builder.where ?? {};
    // Prepare sessionIn
    if (isQueryPart(builder.where.sessionIn)) {
      builder.where.sessionIn.append(query` INTERSECT `);
    } else if (
      Array.isArray(builder.where.sessionIn) &&
      builder.where.sessionIn.length > 0
    ) {
      builder.where.sessionIn = query(
        [
          "(SELECT value::uuid FROM(values (",
          ...Array.from({ length: builder.where.sessionIn.length - 1 }).map(
            () => "), (",
          ),
          ")) as ids(value)) INTERSECT ",
        ],
        ...builder.where.sessionIn,
      );
    } else {
      builder.where.sessionIn = query``;
    }
    const offsetLimitQb = !isNil(builder.viaSession.offset)
      ? query`OFFSET ${builder.viaSession.offset}`
      : query``;
    if (!isNil(builder.viaSession.limit)) {
      offsetLimitQb.append(
        query`FETCH NEXT ${builder.viaSession.limit} ROWS ONLY`,
      );
    }
    builder.where.sessionIn.append(query`
SELECT DISTINCT ss."id"
${internalQuerySessionStore(builder.viaSession ?? {})}
${offsetLimitQb}
`);
  }
  if (builder.viaRefreshToken) {
    builder.where = builder.where ?? {};
    // Prepare refreshTokenIn
    if (isQueryPart(builder.where.refreshTokenIn)) {
      builder.where.refreshTokenIn.append(query` INTERSECT `);
    } else if (
      Array.isArray(builder.where.refreshTokenIn) &&
      builder.where.refreshTokenIn.length > 0
    ) {
      builder.where.refreshTokenIn = query(
        [
          "(SELECT value::uuid FROM(values (",
          ...Array.from({
            length: builder.where.refreshTokenIn.length - 1,
          }).map(() => "), ("),
          ")) as ids(value)) INTERSECT ",
        ],
        ...builder.where.refreshTokenIn,
      );
    } else {
      builder.where.refreshTokenIn = query``;
    }
    const offsetLimitQb = !isNil(builder.viaRefreshToken.offset)
      ? query`OFFSET ${builder.viaRefreshToken.offset}`
      : query``;
    if (!isNil(builder.viaRefreshToken.limit)) {
      offsetLimitQb.append(
        query`FETCH NEXT ${builder.viaRefreshToken.limit} ROWS ONLY`,
      );
    }
    builder.where.refreshTokenIn.append(query`
SELECT DISTINCT sst."id"
${internalQuerySessionStoreToken(builder.viaRefreshToken ?? {})}
${offsetLimitQb}
`);
  }
  if (builder.viaAccessToken) {
    builder.where = builder.where ?? {};
    // Prepare idIn
    if (isQueryPart(builder.where.idIn)) {
      builder.where.idIn.append(query` INTERSECT `);
    } else if (
      Array.isArray(builder.where.idIn) &&
      builder.where.idIn.length > 0
    ) {
      builder.where.idIn = query(
        [
          "(SELECT value::uuid FROM(values (",
          ...Array.from({ length: builder.where.idIn.length - 1 }).map(
            () => "), (",
          ),
          ")) as ids(value)) INTERSECT ",
        ],
        ...builder.where.idIn,
      );
    } else {
      builder.where.idIn = query``;
    }
    const offsetLimitQb = !isNil(builder.viaAccessToken.offset)
      ? query`OFFSET ${builder.viaAccessToken.offset}`
      : query``;
    if (!isNil(builder.viaAccessToken.limit)) {
      offsetLimitQb.append(
        query`FETCH NEXT ${builder.viaAccessToken.limit} ROWS ONLY`,
      );
    }
    builder.where.idIn.append(query`
SELECT DISTINCT sst."refreshToken"
${internalQuerySessionStoreToken(builder.viaAccessToken ?? {})}
${offsetLimitQb}
`);
  }
  if (builder.session) {
    const joinedKeys = [];
    const offsetLimitQb = !isNil(builder.session.offset)
      ? query`OFFSET ${builder.session.offset}`
      : query``;
    if (!isNil(builder.session.limit)) {
      offsetLimitQb.append(
        query`FETCH NEXT ${builder.session.limit} ROWS ONLY`,
      );
    }
    if (builder.session.accessTokens) {
      joinedKeys.push(
        `'${builder.session.accessTokens?.as ?? "accessTokens"}'`,
        `coalesce("ss_sst_0"."result", '{}')`,
      );
    }
    joinQb.append(query`LEFT JOIN LATERAL (
SELECT to_jsonb(ss.*) || jsonb_build_object(${query([
      joinedKeys.join(","),
    ])}) as "result"
${internalQuerySessionStore(
  builder.session ?? {},
  query`AND ss."id" = sst2."session"`,
)}
ORDER BY ${sessionStoreOrderBy(
      builder.session.orderBy,
      builder.session.orderBySpec,
      "ss.",
    )}
${offsetLimitQb}
) as "sst_ss_0" ON TRUE`);
  }
  if (builder.refreshToken) {
    const joinedKeys = [];
    const offsetLimitQb = !isNil(builder.refreshToken.offset)
      ? query`OFFSET ${builder.refreshToken.offset}`
      : query``;
    if (!isNil(builder.refreshToken.limit)) {
      offsetLimitQb.append(
        query`FETCH NEXT ${builder.refreshToken.limit} ROWS ONLY`,
      );
    }
    if (builder.refreshToken.session) {
      joinedKeys.push(
        `'${builder.refreshToken.session?.as ?? "session"}'`,
        `"sst_ss_0"."result"`,
      );
    }
    if (builder.refreshToken.refreshToken) {
      joinedKeys.push(
        `'${builder.refreshToken.refreshToken?.as ?? "refreshToken"}'`,
        `"sst_sst_0"."result"`,
      );
    }
    if (builder.refreshToken.accessToken) {
      joinedKeys.push(
        `'${builder.refreshToken.accessToken?.as ?? "accessToken"}'`,
        `"sst_sst_1"."result"`,
      );
    }
    joinQb.append(query`LEFT JOIN LATERAL (
SELECT to_jsonb(sst.*) || jsonb_build_object(${query([
      joinedKeys.join(","),
    ])}) as "result"
${internalQuerySessionStoreToken(
  builder.refreshToken ?? {},
  query`AND sst."id" = sst2."refreshToken"`,
)}
ORDER BY ${sessionStoreTokenOrderBy(
      builder.refreshToken.orderBy,
      builder.refreshToken.orderBySpec,
      "sst.",
    )}
${offsetLimitQb}
) as "sst_sst_0" ON TRUE`);
  }
  if (builder.accessToken) {
    const joinedKeys = [];
    const offsetLimitQb = !isNil(builder.accessToken.offset)
      ? query`OFFSET ${builder.accessToken.offset}`
      : query``;
    if (!isNil(builder.accessToken.limit)) {
      offsetLimitQb.append(
        query`FETCH NEXT ${builder.accessToken.limit} ROWS ONLY`,
      );
    }
    if (builder.accessToken.session) {
      joinedKeys.push(
        `'${builder.accessToken.session?.as ?? "session"}'`,
        `"sst_ss_0"."result"`,
      );
    }
    if (builder.accessToken.refreshToken) {
      joinedKeys.push(
        `'${builder.accessToken.refreshToken?.as ?? "refreshToken"}'`,
        `"sst_sst_0"."result"`,
      );
    }
    if (builder.accessToken.accessToken) {
      joinedKeys.push(
        `'${builder.accessToken.accessToken?.as ?? "accessToken"}'`,
        `"sst_sst_1"."result"`,
      );
    }
    joinQb.append(query`LEFT JOIN LATERAL (
SELECT to_jsonb(sst.*) || jsonb_build_object(${query([
      joinedKeys.join(","),
    ])}) as "result"
${internalQuerySessionStoreToken(
  builder.accessToken ?? {},
  query`AND sst."refreshToken" = sst2."id"`,
)}
ORDER BY ${sessionStoreTokenOrderBy(
      builder.accessToken.orderBy,
      builder.accessToken.orderBySpec,
      "sst.",
    )}
${offsetLimitQb}
) as "sst_sst_1" ON TRUE`);
  }
  return query`
FROM "sessionStoreToken" sst2
${joinQb}
WHERE ${sessionStoreTokenWhere(builder.where, "sst2.", {
    skipValidator: true,
  })} ${wherePartial}
`;
}
/**
 * @param {StoreSessionStoreTokenQueryBuilder & StoreSessionStoreTokenQueryTraverser} builder
 * @param {QueryPart|undefined} [wherePartial]
 * @returns {QueryPart}
 */
export function internalQuerySessionStoreToken(builder, wherePartial) {
  const joinQb = query``;
  if (builder.viaSession) {
    builder.where = builder.where ?? {};
    // Prepare sessionIn
    if (isQueryPart(builder.where.sessionIn)) {
      builder.where.sessionIn.append(query` INTERSECT `);
    } else if (
      Array.isArray(builder.where.sessionIn) &&
      builder.where.sessionIn.length > 0
    ) {
      builder.where.sessionIn = query(
        [
          "(SELECT value::uuid FROM(values (",
          ...Array.from({ length: builder.where.sessionIn.length - 1 }).map(
            () => "), (",
          ),
          ")) as ids(value)) INTERSECT ",
        ],
        ...builder.where.sessionIn,
      );
    } else {
      builder.where.sessionIn = query``;
    }
    const offsetLimitQb = !isNil(builder.viaSession.offset)
      ? query`OFFSET ${builder.viaSession.offset}`
      : query``;
    if (!isNil(builder.viaSession.limit)) {
      offsetLimitQb.append(
        query`FETCH NEXT ${builder.viaSession.limit} ROWS ONLY`,
      );
    }
    builder.where.sessionIn.append(query`
SELECT DISTINCT ss."id"
${internalQuerySessionStore(builder.viaSession ?? {})}
${offsetLimitQb}
`);
  }
  if (builder.viaRefreshToken) {
    builder.where = builder.where ?? {};
    // Prepare refreshTokenIn
    if (isQueryPart(builder.where.refreshTokenIn)) {
      builder.where.refreshTokenIn.append(query` INTERSECT `);
    } else if (
      Array.isArray(builder.where.refreshTokenIn) &&
      builder.where.refreshTokenIn.length > 0
    ) {
      builder.where.refreshTokenIn = query(
        [
          "(SELECT value::uuid FROM(values (",
          ...Array.from({
            length: builder.where.refreshTokenIn.length - 1,
          }).map(() => "), ("),
          ")) as ids(value)) INTERSECT ",
        ],
        ...builder.where.refreshTokenIn,
      );
    } else {
      builder.where.refreshTokenIn = query``;
    }
    const offsetLimitQb = !isNil(builder.viaRefreshToken.offset)
      ? query`OFFSET ${builder.viaRefreshToken.offset}`
      : query``;
    if (!isNil(builder.viaRefreshToken.limit)) {
      offsetLimitQb.append(
        query`FETCH NEXT ${builder.viaRefreshToken.limit} ROWS ONLY`,
      );
    }
    builder.where.refreshTokenIn.append(query`
SELECT DISTINCT sst2."id"
${internalQuerySessionStoreToken2(builder.viaRefreshToken ?? {})}
${offsetLimitQb}
`);
  }
  if (builder.viaAccessToken) {
    builder.where = builder.where ?? {};
    // Prepare idIn
    if (isQueryPart(builder.where.idIn)) {
      builder.where.idIn.append(query` INTERSECT `);
    } else if (
      Array.isArray(builder.where.idIn) &&
      builder.where.idIn.length > 0
    ) {
      builder.where.idIn = query(
        [
          "(SELECT value::uuid FROM(values (",
          ...Array.from({ length: builder.where.idIn.length - 1 }).map(
            () => "), (",
          ),
          ")) as ids(value)) INTERSECT ",
        ],
        ...builder.where.idIn,
      );
    } else {
      builder.where.idIn = query``;
    }
    const offsetLimitQb = !isNil(builder.viaAccessToken.offset)
      ? query`OFFSET ${builder.viaAccessToken.offset}`
      : query``;
    if (!isNil(builder.viaAccessToken.limit)) {
      offsetLimitQb.append(
        query`FETCH NEXT ${builder.viaAccessToken.limit} ROWS ONLY`,
      );
    }
    builder.where.idIn.append(query`
SELECT DISTINCT sst2."refreshToken"
${internalQuerySessionStoreToken2(builder.viaAccessToken ?? {})}
${offsetLimitQb}
`);
  }
  if (builder.session) {
    const joinedKeys = [];
    const offsetLimitQb = !isNil(builder.session.offset)
      ? query`OFFSET ${builder.session.offset}`
      : query``;
    if (!isNil(builder.session.limit)) {
      offsetLimitQb.append(
        query`FETCH NEXT ${builder.session.limit} ROWS ONLY`,
      );
    }
    if (builder.session.accessTokens) {
      joinedKeys.push(
        `'${builder.session.accessTokens?.as ?? "accessTokens"}'`,
        `coalesce("ss_sst_0"."result", '{}')`,
      );
    }
    joinQb.append(query`LEFT JOIN LATERAL (
SELECT to_jsonb(ss.*) || jsonb_build_object(${query([
      joinedKeys.join(","),
    ])}) as "result"
${internalQuerySessionStore(
  builder.session ?? {},
  query`AND ss."id" = sst."session"`,
)}
ORDER BY ${sessionStoreOrderBy(
      builder.session.orderBy,
      builder.session.orderBySpec,
      "ss.",
    )}
${offsetLimitQb}
) as "sst_ss_0" ON TRUE`);
  }
  if (builder.refreshToken) {
    const joinedKeys = [];
    const offsetLimitQb = !isNil(builder.refreshToken.offset)
      ? query`OFFSET ${builder.refreshToken.offset}`
      : query``;
    if (!isNil(builder.refreshToken.limit)) {
      offsetLimitQb.append(
        query`FETCH NEXT ${builder.refreshToken.limit} ROWS ONLY`,
      );
    }
    if (builder.refreshToken.session) {
      joinedKeys.push(
        `'${builder.refreshToken.session?.as ?? "session"}'`,
        `"sst_ss_0"."result"`,
      );
    }
    if (builder.refreshToken.refreshToken) {
      joinedKeys.push(
        `'${builder.refreshToken.refreshToken?.as ?? "refreshToken"}'`,
        `"sst_sst_0"."result"`,
      );
    }
    if (builder.refreshToken.accessToken) {
      joinedKeys.push(
        `'${builder.refreshToken.accessToken?.as ?? "accessToken"}'`,
        `"sst_sst_1"."result"`,
      );
    }
    joinQb.append(query`LEFT JOIN LATERAL (
SELECT to_jsonb(sst2.*) || jsonb_build_object(${query([
      joinedKeys.join(","),
    ])}) as "result"
${internalQuerySessionStoreToken2(
  builder.refreshToken ?? {},
  query`AND sst2."id" = sst."refreshToken"`,
)}
ORDER BY ${sessionStoreTokenOrderBy(
      builder.refreshToken.orderBy,
      builder.refreshToken.orderBySpec,
      "sst2.",
    )}
${offsetLimitQb}
) as "sst_sst_0" ON TRUE`);
  }
  if (builder.accessToken) {
    const joinedKeys = [];
    const offsetLimitQb = !isNil(builder.accessToken.offset)
      ? query`OFFSET ${builder.accessToken.offset}`
      : query``;
    if (!isNil(builder.accessToken.limit)) {
      offsetLimitQb.append(
        query`FETCH NEXT ${builder.accessToken.limit} ROWS ONLY`,
      );
    }
    if (builder.accessToken.session) {
      joinedKeys.push(
        `'${builder.accessToken.session?.as ?? "session"}'`,
        `"sst_ss_0"."result"`,
      );
    }
    if (builder.accessToken.refreshToken) {
      joinedKeys.push(
        `'${builder.accessToken.refreshToken?.as ?? "refreshToken"}'`,
        `"sst_sst_0"."result"`,
      );
    }
    if (builder.accessToken.accessToken) {
      joinedKeys.push(
        `'${builder.accessToken.accessToken?.as ?? "accessToken"}'`,
        `"sst_sst_1"."result"`,
      );
    }
    joinQb.append(query`LEFT JOIN LATERAL (
SELECT to_jsonb(sst2.*) || jsonb_build_object(${query([
      joinedKeys.join(","),
    ])}) as "result"
${internalQuerySessionStoreToken2(
  builder.accessToken ?? {},
  query`AND sst2."refreshToken" = sst."id"`,
)}
ORDER BY ${sessionStoreTokenOrderBy(
      builder.accessToken.orderBy,
      builder.accessToken.orderBySpec,
      "sst2.",
    )}
${offsetLimitQb}
) as "sst_sst_1" ON TRUE`);
  }
  return query`
FROM "sessionStoreToken" sst
${joinQb}
WHERE ${sessionStoreTokenWhere(builder.where, "sst.", {
    skipValidator: true,
  })} ${wherePartial}
`;
}
/**
 * Query Builder for sessionStoreToken
 * Note that nested limit and offset don't work yet.
 *
 * @param {StoreSessionStoreTokenQueryBuilder} [builder={}]
 * @returns {{
 *  then: () => void,
 *  exec: (sql: Postgres) => Promise<QueryResultStoreSessionStoreToken[]>,
 *  execRaw: (sql: Postgres) => Promise<any[]>,
 *  queryPart: QueryPart<any>,
 * }}
 */
export function querySessionStoreToken(builder = {}) {
  const joinedKeys = [];
  const builderValidated = validateStoreSessionStoreTokenQueryBuilder(
    builder,
    "$.sessionStoreTokenBuilder",
  );
  if (builderValidated.error) {
    throw builderValidated.error;
  }
  builder = builderValidated.value;
  if (builder.session) {
    joinedKeys.push(
      `'${builder.session?.as ?? "session"}'`,
      `"sst_ss_0"."result"`,
    );
  }
  if (builder.refreshToken) {
    joinedKeys.push(
      `'${builder.refreshToken?.as ?? "refreshToken"}'`,
      `"sst_sst_0"."result"`,
    );
  }
  if (builder.accessToken) {
    joinedKeys.push(
      `'${builder.accessToken?.as ?? "accessToken"}'`,
      `"sst_sst_1"."result"`,
    );
  }
  const qb = query`
SELECT to_jsonb(sst.*) || jsonb_build_object(${query([
    joinedKeys.join(","),
  ])}) as "result"
${internalQuerySessionStoreToken(builder ?? {})}
ORDER BY ${sessionStoreTokenOrderBy(builder.orderBy, builder.orderBySpec)}
`;
  if (!isNil(builder.offset)) {
    qb.append(query`OFFSET ${builder.offset}`);
  }
  if (!isNil(builder.limit)) {
    qb.append(query`FETCH NEXT ${builder.limit} ROWS ONLY`);
  }
  return {
    then: () => {
      throw AppError.serverError({
        message:
          "Awaited 'querySessionStoreToken' directly. Please use '.exec' or '.execRaw'.",
      });
    },
    execRaw: async (sql) => await qb.exec(sql),
    exec: async (sql) => {
      const result = await qb.exec(sql);
      transformSessionStoreToken(result, builder);
      return result;
    },
    get queryPart() {
      return qb;
    },
  };
}
/**
 * NOTE: At the moment only intended for internal use by the generated queries!
 *
 * Transform results from the query builder that adhere to the known structure
 * of 'sessionStoreToken' and its relations.
 *
 * @param {any[]} values
 * @param {StoreSessionStoreTokenQueryBuilder} [builder={}]
 */
export function transformSessionStoreToken(values, builder = {}) {
  for (let i = 0; i < values.length; ++i) {
    let value = values[i];
    if (isPlainObject(value.result) && Object.keys(value).length === 1) {
      values[i] = value.result;
      value = value.result;
    }
    if (typeof value.expiresAt === "string") {
      value.expiresAt = new Date(value.expiresAt);
    }
    value.refreshToken = value.refreshToken ?? undefined;
    value.revokedAt = value.revokedAt ?? undefined;
    if (typeof value.revokedAt === "string") {
      value.revokedAt = new Date(value.revokedAt);
    }
    value[builder.session?.as ?? "session"] =
      value[builder.session?.as ?? "session"] ?? undefined;
    if (isPlainObject(value[builder.session?.as ?? "session"])) {
      const arr = [value[builder.session?.as ?? "session"]];
      transformSessionStore(arr, builder.session);
      value[builder.session?.as ?? "session"] = arr[0];
    }
    value[builder.refreshToken?.as ?? "refreshToken"] =
      value[builder.refreshToken?.as ?? "refreshToken"] ?? undefined;
    if (isPlainObject(value[builder.refreshToken?.as ?? "refreshToken"])) {
      const arr = [value[builder.refreshToken?.as ?? "refreshToken"]];
      transformSessionStoreToken(arr, builder.refreshToken);
      value[builder.refreshToken?.as ?? "refreshToken"] = arr[0];
    }
    value[builder.accessToken?.as ?? "accessToken"] =
      value[builder.accessToken?.as ?? "accessToken"] ?? undefined;
    if (isPlainObject(value[builder.accessToken?.as ?? "accessToken"])) {
      const arr = [value[builder.accessToken?.as ?? "accessToken"]];
      transformSessionStoreToken(arr, builder.accessToken);
      value[builder.accessToken?.as ?? "accessToken"] = arr[0];
    }
  }
}
