// Generated by @compas/code-gen

import { AppError, isNil } from "@compas/stdlib";
import { wrapQueryPart } from "../common/database-helpers.js";
import { validateQueryResultStoreSessionStoreToken } from "../queryResult/validators.js";
import {
  validateStoreSessionStoreToken,
  validateStoreSessionStoreTokenInsertValidated,
  validateStoreSessionStoreTokenOrderBy,
  validateStoreSessionStoreTokenOrderBySpec,
  validateStoreSessionStoreTokenQueryBuilderValidated,
  validateStoreSessionStoreTokenUpdateValidated,
  validateStoreSessionStoreTokenWhereValidated,
} from "../store/validators.js";
import {
  sessionStoreQueryBuilderSpec,
  sessionStoreWhereSpec,
} from "./sessionStore.js";
import {
  generatedQueryBuilderHelper,
  generatedUpdateHelper,
  generatedWhereBuilderHelper,
  isQueryPart,
  query,
} from "@compas/store";

export const sessionStoreTokenQueries = {
  sessionStoreTokenCount,
  sessionStoreTokenInsert,
  sessionStoreTokenUpdate,
  sessionStoreTokenDelete,
  sessionStoreTokenUpsertOnId,
};

/** @type {any} */
export const sessionStoreTokenWhereSpec = {
  fieldSpecification: [
    {
      tableKey: "id",
      keyType: "uuid",
      matchers: [
        {
          matcherKey: "id",
          matcherType: "equal",
        },
        {
          matcherKey: "idNotEqual",
          matcherType: "notEqual",
        },
        {
          matcherKey: "idIn",
          matcherType: "in",
        },
        {
          matcherKey: "idNotIn",
          matcherType: "notIn",
        },
      ],
    },
    {
      tableKey: "session",
      keyType: "uuid",
      matchers: [
        {
          matcherKey: "session",
          matcherType: "equal",
        },
        {
          matcherKey: "sessionNotEqual",
          matcherType: "notEqual",
        },
        {
          matcherKey: "sessionIn",
          matcherType: "in",
        },
        {
          matcherKey: "sessionNotIn",
          matcherType: "notIn",
        },
        {
          matcherKey: "viaSession",
          matcherType: "via",
          relation: {
            entityName: "sessionStore",
            shortName: "ss",
            entityKey: "id",
            referencedKey: "session",
            where: () => sessionStoreWhereSpec,
          },
        },
      ],
    },
    {
      tableKey: "expiresAt",
      keyType: "timestamptz",
      matchers: [
        {
          matcherKey: "expiresAt",
          matcherType: "equal",
        },
        {
          matcherKey: "expiresAtNotEqual",
          matcherType: "notEqual",
        },
        {
          matcherKey: "expiresAtIn",
          matcherType: "in",
        },
        {
          matcherKey: "expiresAtNotIn",
          matcherType: "notIn",
        },
        {
          matcherKey: "expiresAtGreaterThan",
          matcherType: "greaterThan",
        },
        {
          matcherKey: "expiresAtLowerThan",
          matcherType: "lowerThan",
        },
      ],
    },
    {
      tableKey: "refreshToken",
      keyType: "uuid",
      matchers: [
        {
          matcherKey: "refreshToken",
          matcherType: "equal",
        },
        {
          matcherKey: "refreshTokenNotEqual",
          matcherType: "notEqual",
        },
        {
          matcherKey: "refreshTokenIn",
          matcherType: "in",
        },
        {
          matcherKey: "refreshTokenNotIn",
          matcherType: "notIn",
        },
        {
          matcherKey: "refreshTokenIsNull",
          matcherType: "isNull",
        },
        {
          matcherKey: "refreshTokenIsNotNull",
          matcherType: "isNotNull",
        },
        {
          matcherKey: "viaRefreshToken",
          matcherType: "via",
          relation: {
            entityName: "sessionStoreToken",
            shortName: "sst2",
            entityKey: "id",
            referencedKey: "refreshToken",
            where: () => sessionStoreTokenWhereSpec,
          },
        },
      ],
    },
    {
      tableKey: "revokedAt",
      keyType: "timestamptz",
      matchers: [
        {
          matcherKey: "revokedAt",
          matcherType: "equal",
        },
        {
          matcherKey: "revokedAtNotEqual",
          matcherType: "notEqual",
        },
        {
          matcherKey: "revokedAtIn",
          matcherType: "in",
        },
        {
          matcherKey: "revokedAtNotIn",
          matcherType: "notIn",
        },
        {
          matcherKey: "revokedAtGreaterThan",
          matcherType: "greaterThan",
        },
        {
          matcherKey: "revokedAtLowerThan",
          matcherType: "lowerThan",
        },
        {
          matcherKey: "revokedAtIsNull",
          matcherType: "isNull",
        },
        {
          matcherKey: "revokedAtIsNotNull",
          matcherType: "isNotNull",
        },
      ],
    },
    {
      tableKey: "accessToken",
      matchers: [
        {
          matcherKey: "viaAccessToken",
          matcherType: "via",
          relation: {
            entityName: "sessionStoreToken",
            shortName: "sst2",
            entityKey: "refreshToken",
            referencedKey: "id",
            where: () => sessionStoreTokenWhereSpec,
          },
        },
        {
          matcherKey: "accessTokenNotExists",
          matcherType: "notExists",
          relation: {
            entityName: "sessionStoreToken",
            shortName: "sst2",
            entityKey: "refreshToken",
            referencedKey: "id",
            where: () => sessionStoreTokenWhereSpec,
          },
        },
      ],
    },
  ],
};

/**
 * Reusable where clause generator. This is used by other generated queries, and can be used inline
 * in custom queries.
 *
 * @param {import("../common/types.js").StoreSessionStoreTokenWhere} [where]
 * @param {{ skipValidator?: boolean, shortName?: string }} [options]
 * @returns {import("@compas/store").QueryPart<any>}
 */
export function sessionStoreTokenWhere(where, options = {}) {
  options.shortName ??= "sst.";
  if (!options.shortName.endsWith(".")) {
    options.shortName += ".";
  }
  if (!options.skipValidator) {
    const { error, value } = validateStoreSessionStoreTokenWhereValidated(
      where ?? {},
    );
    if (error) {
      throw AppError.serverError({ message: "Invalid where object", error });
    }
    where = value;
  }
  return generatedWhereBuilderHelper(
    sessionStoreTokenWhereSpec,
    where ?? {},
    options.shortName,
  );
}

/**
 * Reusable ORDER BY clause generator. This is used by other generated queries, and can be used
 * inline in custom queries.
 *
 * @param {import("../common/types.js").StoreSessionStoreTokenOrderBy} [orderBy]
 * @param {import("../common/types.js").StoreSessionStoreTokenOrderBySpec} [orderBySpec]
 * @param {{ skipValidator?: boolean, shortName?: string }} [options]
 * @returns {import("@compas/store").QueryPart<any>}
 */
export function sessionStoreTokenOrderBy(orderBy, orderBySpec, options = {}) {
  options.shortName ??= "sst.";
  if (!options.shortName.endsWith(".")) {
    options.shortName += ".";
  }
  orderBy ??= ["id"];
  orderBySpec ??= {};
  if (!options.skipValidator) {
    const validatedOrderBy = validateStoreSessionStoreTokenOrderBy(orderBy);
    if (validatedOrderBy.error) {
      throw AppError.serverError({
        message: "Invalid orderBy array",
        error: validatedOrderBy.error,
      });
    }
    orderBy = validatedOrderBy.value;
    const validatedOrderBySpec =
      validateStoreSessionStoreTokenOrderBySpec(orderBySpec);
    if (validatedOrderBySpec.error) {
      throw AppError.serverError({
        message: "Invalid orderBySpec object",
        error: validatedOrderBySpec.error,
      });
    }
    orderBySpec = validatedOrderBySpec.value;
  }
  if (isQueryPart(orderBy)) {
    return orderBy;
  }
  let str = "";
  for (const value of orderBy) {
    if (str.length !== 0) {
      str += ", ";
    }
    str += `${options.shortName}"${value}" ${orderBySpec[value] ?? "ASC"}`;
  }
  return query([str]);
}

/**
 * Count the records in the 'sessionStoreToken' table
 *
 * @param {import("@compas/store").Postgres} sql
 * @param {import("../common/types.js").StoreSessionStoreTokenWhere} where
 * @returns {Promise<number>}
 */
async function sessionStoreTokenCount(sql, where) {
  const [result] =
    await query`select count(sst."id") as "recordCount" FROM "sessionStoreToken" sst WHERE ${sessionStoreTokenWhere(where)}`.exec(
      sql,
    );
  return Number(result?.recordCount ?? "0");
}

/**
 * Insert a record in the 'sessionStoreToken' table
 *
 * @param {import("@compas/store").Postgres} sql
 * @param {import("../common/types.js").StoreSessionStoreTokenInsert["insert"]} insert
 * @param {{ withPrimaryKey?: boolean }} [_options={}]
 * @returns {Promise<Array<import("../common/types.js").StoreSessionStoreToken>>}
 */
function sessionStoreTokenInsert(sql, insert, _options = {}) {
  if (insert === undefined || (Array.isArray(insert) && insert.length === 0)) {
    return Promise.resolve([]);
  }
  return sessionStoreTokenInsertInternal({ insert, returning: "*" }).exec(sql);
}

/**
 * Insert a record in the 'sessionStoreToken' table
 *
 * @param {import("../common/types.js").StoreSessionStoreTokenInsert} input
 * @returns {import("@compas/store").WrappedQueryPart<import("../common/types.js").StoreSessionStoreToken>}
 */
function sessionStoreTokenInsertInternal(input) {
  const { error, value: validatedInput } =
    validateStoreSessionStoreTokenInsertValidated(input);
  if (error) {
    throw AppError.serverError({
      message: "Insert input validation failed",
      error,
    });
  }
  const qb = query`
  INSERT INTO "sessionStoreToken"
    ("id","session","expiresAt","refreshToken","revokedAt","createdAt")
  VALUES
  `;
  /** @type {Array<string>} */
  const str = [];
  const args = [];
  for (const insert of validatedInput.insert) {
    if (str.length) {
      str.push(", (");
    } else {
      str.push("(");
    }
    if (isNil(insert.id)) {
      args.push(undefined);
      str.push("DEFAULT, ");
    } else {
      args.push(insert.id);
      str.push(", ");
    }
    args.push(insert.session ?? null);
    str.push(", ");
    args.push(insert.expiresAt ?? null);
    str.push(", ");
    args.push(insert.refreshToken ?? null);
    str.push(", ");
    args.push(insert.revokedAt ?? null);
    str.push(", ");
    args.push(insert.createdAt ?? null);
    str.push(", ");
    // We have added an extra comma, so remove it.
    str[str.length - 1] = str.at(-1)?.slice(0, -2) ?? "";
    args.push(undefined);
    str.push(")");
    args.push(undefined);
  }
  if (validatedInput.returning === "*") {
    str.push(
      ` RETURNING "id","session","expiresAt","refreshToken","revokedAt","createdAt"`,
    );
    args.push(undefined);
  } else if (Array.isArray(validatedInput.returning)) {
    str.push(
      ` RETURNING ${JSON.stringify(validatedInput.returning).slice(1, -1)}`,
    );
    args.push(undefined);
  }
  qb.append(query(str, ...args));
  return wrapQueryPart(qb, validateStoreSessionStoreToken, {
    hasCustomReturning: Array.isArray(validatedInput.returning),
  });
}

/**
 * Upsert a record in the 'sessionStoreToken' table
 *
 * @param {import("@compas/store").Postgres} sql
 * @param {import("../common/types.js").StoreSessionStoreTokenInsert["insert"]} insert
 * @returns {Promise<Array<import("../common/types.js").StoreSessionStoreToken>>}
 */
function sessionStoreTokenUpsertOnId(sql, insert) {
  return sessionStoreTokenUpsertOnIdInternal({ insert, returning: "*" }).exec(
    sql,
  );
}

/**
 * Upsert a record in the 'sessionStoreToken' table based on the primary key.
 *
 * @param {import("../common/types.js").StoreSessionStoreTokenInsert} input
 * @returns {import("@compas/store").WrappedQueryPart<import("../common/types.js").StoreSessionStoreToken>}
 */
function sessionStoreTokenUpsertOnIdInternal(input) {
  const { error, value: validatedInput } =
    validateStoreSessionStoreTokenInsertValidated(input);
  if (error) {
    throw AppError.serverError({
      message: "Insert input validation failed",
      error,
    });
  }
  const { queryPart } = sessionStoreTokenInsertInternal({
    insert: input.insert,
  });
  /** @type {Array<string>} */
  const str = [];
  const args = [];
  str.push(`ON CONFLICT ("id") DO UPDATE SET
    "session" = COALESCE(EXCLUDED."session", "sessionStoreToken"."session"),
    "expiresAt" = COALESCE(EXCLUDED."expiresAt", "sessionStoreToken"."expiresAt"),
    "refreshToken" = COALESCE(EXCLUDED."refreshToken", "sessionStoreToken"."refreshToken"),
    "revokedAt" = COALESCE(EXCLUDED."revokedAt", "sessionStoreToken"."revokedAt"),
    "createdAt" = COALESCE(EXCLUDED."createdAt", "sessionStoreToken"."createdAt")`);
  if (validatedInput.returning === "*") {
    str.push(
      ` RETURNING "id","session","expiresAt","refreshToken","revokedAt","createdAt"`,
    );
    args.push(undefined);
  } else if (Array.isArray(validatedInput.returning)) {
    str.push(
      ` RETURNING ${JSON.stringify(validatedInput.returning).slice(1, -1)}`,
    );
    args.push(undefined);
  }
  queryPart.append(query(str, ...args));
  return wrapQueryPart(queryPart, validateStoreSessionStoreToken, {
    hasCustomReturning: Array.isArray(validatedInput.returning),
  });
}

/** @type {any} */
const sessionStoreTokenUpdateSpec = {
  schemaName: "",
  name: "sessionStoreToken",
  shortName: "sst",
  columns: [
    "id",
    "session",
    "expiresAt",
    "refreshToken",
    "revokedAt",
    "createdAt",
  ],
  where: sessionStoreTokenWhereSpec,
  injectUpdatedAt: false,
  fields: {
    id: {
      type: "uuid",
      atomicUpdates: [],
    },
    session: {
      type: "uuid",
      atomicUpdates: [],
    },
    expiresAt: {
      type: "date",
      atomicUpdates: ["$add", "$subtract"],
    },
    refreshToken: {
      type: "uuid",
      atomicUpdates: [],
    },
    revokedAt: {
      type: "date",
      atomicUpdates: ["$add", "$subtract"],
    },
    createdAt: {
      type: "date",
      atomicUpdates: ["$add", "$subtract"],
    },
  },
};

/**
 * Insert a record in the 'sessionStoreToken' table
 *
 * @param {import("@compas/store").Postgres} sql
 * @param {import("../common/types.js").StoreSessionStoreTokenUpdate} update
 * @returns {Promise<Array<import("../common/types.js").StoreSessionStoreToken>>}
 */
function sessionStoreTokenUpdate(sql, update) {
  if (update?.returning === "*" || !update?.returning) {
    return sessionStoreTokenUpdateInternal(update).exec(sql);
  }
  // @ts-expect-error
  return sessionStoreTokenUpdateInternal(update).execRaw(sql);
}

/**
 * Update records in the 'sessionStoreToken' table
 *
 * @param {import("../common/types.js").StoreSessionStoreTokenUpdate} input
 * @returns {import("@compas/store").WrappedQueryPart<import("../common/types.js").StoreSessionStoreToken>}
 */
function sessionStoreTokenUpdateInternal(input) {
  const { error, value: validatedInput } =
    validateStoreSessionStoreTokenUpdateValidated(input);
  if (error) {
    throw AppError.serverError({
      message: "Update input validation failed",
      error,
    });
  }
  return wrapQueryPart(
    generatedUpdateHelper(sessionStoreTokenUpdateSpec, validatedInput),
    validateStoreSessionStoreToken,
    { hasCustomReturning: Array.isArray(validatedInput.returning) },
  );
}

/**
 * Insert a record in the 'sessionStoreToken' table
 *
 * @param {import("@compas/store").Postgres} sql
 * @param {import("../common/types.js").StoreSessionStoreTokenWhere} [where]
 * @returns {Promise<void>}
 */
function sessionStoreTokenDelete(sql, where = {}) {
  return sessionStoreTokenDeleteInternal(where).exec(sql);
}

/**
 * Remove records from the 'sessionStoreToken' table
 *
 * @param {import("../common/types.js").StoreSessionStoreTokenWhere} [where]
 * @returns {import("@compas/store").QueryPart<any>}
 */
function sessionStoreTokenDeleteInternal(where = {}) {
  return query`DELETE FROM "sessionStoreToken" sst WHERE ${sessionStoreTokenWhere(where)}`;
}

/** @type {any} */
export const sessionStoreTokenQueryBuilderSpec = {
  name: "sessionStoreToken",
  shortName: "sst",
  orderByExperimental: sessionStoreTokenOrderBy,
  where: sessionStoreTokenWhereSpec,
  columns: [
    "id",
    "session",
    "expiresAt",
    "refreshToken",
    "revokedAt",
    "createdAt",
  ],
  relations: [
    {
      builderKey: "refreshToken",
      ownKey: "refreshToken",
      referencedKey: "id",
      returnsMany: false,
      entityInformation: () => sessionStoreTokenQueryBuilderSpec,
    },
    {
      builderKey: "session",
      ownKey: "session",
      referencedKey: "id",
      returnsMany: false,
      entityInformation: () => sessionStoreQueryBuilderSpec,
    },
    {
      builderKey: "accessToken",
      ownKey: "id",
      referencedKey: "refreshToken",
      returnsMany: false,
      entityInformation: () => sessionStoreTokenQueryBuilderSpec,
    },
  ],
};

/**
 * Query records in the 'sessionStoreToken' table, optionally joining related tables.
 *
 * @param {import("../common/types.js").StoreSessionStoreTokenQueryBuilder} [input]
 * @returns {import("@compas/store").WrappedQueryPart<import("../common/types.js").QueryResultStoreSessionStoreToken>}
 */
export function querySessionStoreToken(input = {}) {
  const { error, value: validatedInput } =
    validateStoreSessionStoreTokenQueryBuilderValidated(input);
  if (error) {
    throw AppError.serverError({
      message: "Query builder input validation failed",
      error,
    });
  }
  return wrapQueryPart(
    generatedQueryBuilderHelper(
      sessionStoreTokenQueryBuilderSpec,
      validatedInput,
      {},
    ),
    validateQueryResultStoreSessionStoreToken,
    { hasCustomReturning: validatedInput.select?.length !== 6 },
  );
}
