// Generated by @compas/code-gen
/* eslint-disable no-unused-vars */

import { AppError, isNil, isPlainObject, isStaging } from "@compas/stdlib";
import {
  generatedQueryBuilderHelper,
  generatedWhereBuilderHelper,
  isQueryPart,
  query,
} from "@compas/store";
import {
  validateStoreSessionStoreTokenOrderBy,
  validateStoreSessionStoreTokenOrderBySpec,
  validateStoreSessionStoreTokenQueryBuilder,
  validateStoreSessionStoreTokenWhere,
} from "../store/validators.js";
import {
  sessionStoreQueryBuilderSpec,
  sessionStoreWhere,
  sessionStoreWhereSpec,
  transformSessionStore,
} from "./sessionStore.js";

const sessionStoreTokenFieldSet = new Set([
  "expiresAt",
  "revokedAt",
  "createdAt",
  "id",
  "session",
  "refreshToken",
]);
/**
 * Get all fields for sessionStoreToken
 *
 * @param {string} [tableName="sst."]
 * @param {{ excludePrimaryKey?: boolean }} [options={}]
 * @returns {QueryPart}
 */
export function sessionStoreTokenFields(tableName = "sst.", options = {}) {
  if (tableName.length > 0 && !tableName.endsWith(".")) {
    tableName = `${tableName}.`;
  }
  if (options.excludePrimaryKey) {
    return query([
      `${tableName}"session", ${tableName}"expiresAt", ${tableName}"refreshToken", ${tableName}"revokedAt", ${tableName}"createdAt"`,
    ]);
  }
  return query([
    `${tableName}"id", ${tableName}"session", ${tableName}"expiresAt", ${tableName}"refreshToken", ${tableName}"revokedAt", ${tableName}"createdAt"`,
  ]);
}
/** @type {any} */
export const sessionStoreTokenWhereSpec = {
  fieldSpecification: [
    {
      tableKey: "id",
      keyType: "uuid",
      matchers: [
        { matcherKey: "id", matcherType: "equal" },
        { matcherKey: "idNotEqual", matcherType: "notEqual" },
        { matcherKey: "idIn", matcherType: "in" },
        { matcherKey: "idNotIn", matcherType: "notIn" },
      ],
    },
    {
      tableKey: "session",
      keyType: "uuid",
      matchers: [
        { matcherKey: "session", matcherType: "equal" },
        { matcherKey: "sessionNotEqual", matcherType: "notEqual" },
        { matcherKey: "sessionIn", matcherType: "in" },
        { matcherKey: "sessionNotIn", matcherType: "notIn" },
        {
          matcherKey: "viaSession",
          matcherType: "via",
          relation: {
            entityName: "sessionStore",
            shortName: "ss",
            entityKey: "id",
            referencedKey: "session",
            where: () => sessionStoreWhereSpec,
          },
        },
      ],
    },
    {
      tableKey: "expiresAt",
      keyType: "timestamptz",
      matchers: [
        { matcherKey: "expiresAt", matcherType: "equal" },
        { matcherKey: "expiresAtNotEqual", matcherType: "notEqual" },
        { matcherKey: "expiresAtIn", matcherType: "in" },
        { matcherKey: "expiresAtNotIn", matcherType: "notIn" },
        { matcherKey: "expiresAtGreaterThan", matcherType: "greaterThan" },
        { matcherKey: "expiresAtLowerThan", matcherType: "lowerThan" },
      ],
    },
    {
      tableKey: "refreshToken",
      keyType: "uuid",
      matchers: [
        { matcherKey: "refreshToken", matcherType: "equal" },
        { matcherKey: "refreshTokenNotEqual", matcherType: "notEqual" },
        { matcherKey: "refreshTokenIn", matcherType: "in" },
        { matcherKey: "refreshTokenNotIn", matcherType: "notIn" },
        { matcherKey: "refreshTokenIsNull", matcherType: "isNull" },
        { matcherKey: "refreshTokenIsNotNull", matcherType: "isNotNull" },
        {
          matcherKey: "viaRefreshToken",
          matcherType: "via",
          relation: {
            entityName: "sessionStoreToken",
            shortName: "sst2",
            entityKey: "id",
            referencedKey: "refreshToken",
            where: () => sessionStoreTokenWhereSpec,
          },
        },
      ],
    },
    {
      tableKey: "revokedAt",
      keyType: "timestamptz",
      matchers: [
        { matcherKey: "revokedAt", matcherType: "equal" },
        { matcherKey: "revokedAtNotEqual", matcherType: "notEqual" },
        { matcherKey: "revokedAtIn", matcherType: "in" },
        { matcherKey: "revokedAtNotIn", matcherType: "notIn" },
        { matcherKey: "revokedAtGreaterThan", matcherType: "greaterThan" },
        { matcherKey: "revokedAtLowerThan", matcherType: "lowerThan" },
        { matcherKey: "revokedAtIsNull", matcherType: "isNull" },
        { matcherKey: "revokedAtIsNotNull", matcherType: "isNotNull" },
      ],
    },
    {
      tableKey: "accessToken",
      keyType: "undefined",
      matchers: [
        {
          matcherKey: "viaAccessToken",
          matcherType: "via",
          relation: {
            entityName: "sessionStoreToken",
            shortName: "sst2",
            entityKey: "refreshToken",
            referencedKey: "id",
            where: () => sessionStoreTokenWhereSpec,
          },
        },
        {
          matcherKey: "accessTokenNotExists",
          matcherType: "notExists",
          relation: {
            entityName: "sessionStoreToken",
            shortName: "sst2",
            entityKey: "refreshToken",
            referencedKey: "id",
            where: () => sessionStoreTokenWhereSpec,
          },
        },
      ],
    },
  ],
};
/**
 * Build 'WHERE ' part for sessionStoreToken
 *
 * @param {StoreSessionStoreTokenWhere} [where={}]
 * @param {string} [tableName="sst."]
 * @param {{ skipValidator?: boolean|undefined }} [options={}]
 * @returns {QueryPart}
 */
export function sessionStoreTokenWhere(
  where = {},
  tableName = "sst.",
  options = {},
) {
  if (tableName.length > 0 && !tableName.endsWith(".")) {
    tableName = `${tableName}.`;
  }
  if (!options.skipValidator) {
    const whereValidated = validateStoreSessionStoreTokenWhere(
      where,
      "$.sessionStoreTokenWhere",
    );
    if (whereValidated.error) {
      throw whereValidated.error;
    }
    where = whereValidated.value;
  }
  return generatedWhereBuilderHelper(
    sessionStoreTokenWhereSpec,
    where,
    tableName,
  );
}
/**
 * Build 'ORDER BY ' part for sessionStoreToken
 *
 * @param {StoreSessionStoreTokenOrderBy} [orderBy=["id"]]
 * @param {StoreSessionStoreTokenOrderBySpec} [orderBySpec={}]
 * @param {string} [tableName="sst."]
 * @param {{ skipValidator?: boolean|undefined }} [options={}]
 * @returns {QueryPart}
 */
export function sessionStoreTokenOrderBy(
  orderBy = ["id"],
  orderBySpec = {},
  tableName = "sst.",
  options = {},
) {
  if (tableName.length > 0 && !tableName.endsWith(".")) {
    tableName = `${tableName}.`;
  }
  if (!options.skipValidator) {
    const orderByValidated = validateStoreSessionStoreTokenOrderBy(
      orderBy,
      "$.StoreSessionStoreTokenOrderBy",
    );
    if (orderByValidated.error) {
      throw orderByValidated.error;
    }
    orderBy = orderByValidated.value;
    const orderBySpecValidated = validateStoreSessionStoreTokenOrderBySpec(
      orderBySpec,
      "$.StoreSessionStoreTokenOrderBySpec",
    );
    if (orderBySpecValidated.error) {
      throw orderBySpecValidated.error;
    }
    orderBySpec = orderBySpecValidated.value;
  }
  if (isQueryPart(orderBy)) {
    return orderBy;
  }
  const strings = [];
  const values = [];
  let i = 0;
  for (const value of orderBy) {
    if (i !== 0) {
      strings.push(", ");
      values.push(undefined);
    }
    i++;
    strings.push(`${tableName}"${value}" `, orderBySpec[value] ?? "ASC");
    values.push(undefined, undefined);
  }
  strings.push("");
  return query(strings, ...values);
}
/**
 * Build 'VALUES ' part for sessionStoreToken
 *
 * @param {StoreSessionStoreTokenInsertPartial|StoreSessionStoreTokenInsertPartial[]} insert
 * @param {{ includePrimaryKey?: boolean }} [options={}]
 * @returns {QueryPart}
 */
export function sessionStoreTokenInsertValues(insert, options = {}) {
  if (!Array.isArray(insert)) {
    insert = [insert];
  }
  const str = [];
  const args = [];
  for (let i = 0; i < insert.length; ++i) {
    const it = insert[i];
    checkFieldsInSet(
      "sessionStoreToken",
      "insert",
      sessionStoreTokenFieldSet,
      it,
    );
    str.push("(");
    if (options?.includePrimaryKey) {
      args.push(it.id);
      str.push(", ");
    }
    args.push(it.session ?? null);
    str.push(", ");
    args.push(it.expiresAt ?? null);
    str.push(", ");
    args.push(it.refreshToken ?? null);
    str.push(", ");
    args.push(it.revokedAt ?? null);
    str.push(", ");
    args.push(it.createdAt ?? null);
    str.push(", ");
    // Fixup last comma & add undefined arg so strings are concatted correctly
    const lastStrIdx = str.length - 1;
    str[lastStrIdx] = str[lastStrIdx].substring(0, str[lastStrIdx].length - 2);
    args.push(undefined);
    str.push(")");
    args.push(undefined);
    if (i !== insert.length - 1) {
      args.push(undefined);
      str.push(",");
    }
  }
  return query(str, ...args);
}
/**
 * Build 'SET ' part for sessionStoreToken
 *
 * @param {StoreSessionStoreTokenUpdatePartial} update
 * @returns {QueryPart}
 */
export function sessionStoreTokenUpdateSet(update) {
  const strings = [];
  const values = [];
  checkFieldsInSet(
    "sessionStoreToken",
    "update",
    sessionStoreTokenFieldSet,
    update,
  );
  if (update.session !== undefined) {
    strings.push(`, "session" = `);
    values.push(update.session ?? null);
  }
  if (update.expiresAt !== undefined) {
    strings.push(`, "expiresAt" = `);
    values.push(update.expiresAt ?? null);
  }
  if (update.refreshToken !== undefined) {
    strings.push(`, "refreshToken" = `);
    values.push(update.refreshToken ?? null);
  }
  if (update.revokedAt !== undefined) {
    strings.push(`, "revokedAt" = `);
    values.push(update.revokedAt ?? null);
  }
  if (update.createdAt !== undefined) {
    strings.push(`, "createdAt" = `);
    values.push(update.createdAt ?? null);
  }
  // Remove the comma suffix
  if (strings.length === 0) {
    throw AppError.validationError(
      "sessionStoreToken.updateSet.emptyUpdateStatement",
    );
  }
  strings[0] = strings[0].substring(2);
  strings.push("");
  return query(strings, ...values);
}
/**
 * @param {string} entity
 * @param {string} subType
 * @param {Set} set
 * @param {*} value
 */
function checkFieldsInSet(entity, subType, set, value) {
  if (isStaging()) {
    for (const key of Object.keys(value)) {
      if (!set.has(key) && value[key] !== undefined) {
        throw new AppError(`query.${entity}.${subType}Fields`, 500, {
          extraKey: key,
          knownKeys: [...set],
        });
      }
    }
  }
}
/**
 * @param {Postgres} sql
 * @param {StoreSessionStoreTokenWhere} [where]
 * @returns {Promise<number>}
 */
async function sessionStoreTokenCount(sql, where) {
  const [result] = await query`
SELECT COUNT(sst."id") as "countResult"
FROM "sessionStoreToken" sst
WHERE ${sessionStoreTokenWhere(where)}
`.exec(sql);
  return Number(result?.countResult ?? "0");
}
/**
 * @param {Postgres} sql
 * @param {StoreSessionStoreTokenWhere} [where={}]
 * @returns {Promise<void>}
 */
async function sessionStoreTokenDelete(sql, where = {}) {
  return await query`
DELETE FROM "sessionStoreToken" sst
WHERE ${sessionStoreTokenWhere(where)}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreSessionStoreTokenInsertPartial|(StoreSessionStoreTokenInsertPartial[])} insert
 * @param {{ withPrimaryKey?: boolean }} [options={}]
 * @returns {Promise<StoreSessionStoreToken[]>}
 */
async function sessionStoreTokenInsert(sql, insert, options = {}) {
  if (insert === undefined || (Array.isArray(insert) && insert.length === 0)) {
    return [];
  }
  options.withPrimaryKey = options.withPrimaryKey ?? false;
  const result = await query`
INSERT INTO "sessionStoreToken" (${sessionStoreTokenFields("", {
    excludePrimaryKey: !options.withPrimaryKey,
  })})
VALUES ${sessionStoreTokenInsertValues(insert, {
    includePrimaryKey: options.withPrimaryKey,
  })}
RETURNING ${sessionStoreTokenFields("")}
`.exec(sql);
  transformSessionStoreToken(result);
  return result;
}
/**
 * @param {Postgres} sql
 * @param {StoreSessionStoreTokenInsertPartial|(StoreSessionStoreTokenInsertPartial[])} insert
 * @param {{}} [options={}]
 * @returns {Promise<StoreSessionStoreToken[]>}
 */
async function sessionStoreTokenUpsertOnId(sql, insert, options = {}) {
  if (insert === undefined || (Array.isArray(insert) && insert.length === 0)) {
    return [];
  }
  const fieldString = [...sessionStoreTokenFieldSet]
    .filter((it) => it !== "id" && it !== "createdAt")
    .map(
      (column) =>
        `"${column}" = COALESCE(EXCLUDED."${column}", "sessionStoreToken"."${column}")`,
    )
    .join(",");
  const result = await query`
INSERT INTO "sessionStoreToken" (${sessionStoreTokenFields("", {
    excludePrimaryKey: false,
  })})
VALUES ${sessionStoreTokenInsertValues(insert, { includePrimaryKey: true })}
ON CONFLICT ("id") DO UPDATE SET ${query([fieldString])}
RETURNING ${sessionStoreTokenFields("")}
`.exec(sql);
  transformSessionStoreToken(result);
  return result;
}
/**
 * @param {Postgres} sql
 * @param {StoreSessionStoreTokenUpdatePartial} update
 * @param {StoreSessionStoreTokenWhere} [where={}]
 * @returns {Promise<StoreSessionStoreToken[]>}
 */
async function sessionStoreTokenUpdate(sql, update, where = {}) {
  const result = await query`
UPDATE "sessionStoreToken" sst
SET ${sessionStoreTokenUpdateSet(update)}
WHERE ${sessionStoreTokenWhere(where)}
RETURNING ${sessionStoreTokenFields()}
`.exec(sql);
  transformSessionStoreToken(result);
  return result;
}
export const sessionStoreTokenQueries = {
  sessionStoreTokenCount,
  sessionStoreTokenDelete,
  sessionStoreTokenInsert,
  sessionStoreTokenUpsertOnId,
  sessionStoreTokenUpdate,
};
export const sessionStoreTokenQueryBuilderSpec = {
  name: "sessionStoreToken",
  shortName: "sst",
  orderBy: sessionStoreTokenOrderBy,
  where: sessionStoreTokenWhereSpec,
  columns: [
    "expiresAt",
    "revokedAt",
    "createdAt",
    "id",
    "session",
    "refreshToken",
  ],
  relations: [
    {
      builderKey: "session",
      ownKey: "session",
      referencedKey: "id",
      returnsMany: false,
      entityInformation: () => sessionStoreQueryBuilderSpec,
    },
    {
      builderKey: "refreshToken",
      ownKey: "refreshToken",
      referencedKey: "id",
      returnsMany: false,
      entityInformation: () => sessionStoreTokenQueryBuilderSpec,
    },
    {
      builderKey: "accessToken",
      ownKey: "id",
      referencedKey: "refreshToken",
      returnsMany: false,
      entityInformation: () => sessionStoreTokenQueryBuilderSpec,
    },
  ],
};
/**
 * Query Builder for sessionStoreToken
 *
 * @param {StoreSessionStoreTokenQueryBuilder} [builder={}]
 * @returns {{
 *  then: () => void,
 *  exec: (sql: Postgres) => Promise<QueryResultStoreSessionStoreToken[]>,
 *  execRaw: (sql: Postgres) => Promise<any[]>,
 *  queryPart: QueryPart<any>,
 * }}
 */
export function querySessionStoreToken(builder = {}) {
  const builderValidated = validateStoreSessionStoreTokenQueryBuilder(
    builder,
    "$.sessionStoreTokenBuilder",
  );
  if (builderValidated.error) {
    throw builderValidated.error;
  }
  builder = builderValidated.value;
  const qb = generatedQueryBuilderHelper(
    sessionStoreTokenQueryBuilderSpec,
    builder,
    {},
  );
  return {
    then: () => {
      throw AppError.serverError({
        message:
          "Awaited 'querySessionStoreToken' directly. Please use '.exec' or '.execRaw'.",
      });
    },
    execRaw: async (sql) => await qb.exec(sql),
    exec: async (sql) => {
      const result = await qb.exec(sql);
      transformSessionStoreToken(result, builder);
      return result;
    },
    get queryPart() {
      return qb;
    },
  };
}
/**
 * NOTE: At the moment only intended for internal use by the generated queries!
 *
 * Transform results from the query builder that adhere to the known structure
 * of 'sessionStoreToken' and its relations.
 *
 * @param {any[]} values
 * @param {StoreSessionStoreTokenQueryBuilder} [builder={}]
 */
export function transformSessionStoreToken(values, builder = {}) {
  for (let i = 0; i < values.length; ++i) {
    let value = values[i];
    if (isPlainObject(value.result) && Object.keys(value).length === 1) {
      values[i] = value.result;
      value = value.result;
    }
    if (typeof value.expiresAt === "string") {
      value.expiresAt = new Date(value.expiresAt);
    }
    value.refreshToken = value.refreshToken ?? undefined;
    value.revokedAt = value.revokedAt ?? undefined;
    if (typeof value.revokedAt === "string") {
      value.revokedAt = new Date(value.revokedAt);
    }
    if (typeof value.createdAt === "string") {
      value.createdAt = new Date(value.createdAt);
    }
    value[builder.session?.as ?? "session"] =
      value[builder.session?.as ?? "session"] ?? undefined;
    if (isPlainObject(value[builder.session?.as ?? "session"])) {
      const arr = [value[builder.session?.as ?? "session"]];
      transformSessionStore(arr, builder.session);
      value[builder.session?.as ?? "session"] = arr[0];
    }
    value[builder.refreshToken?.as ?? "refreshToken"] =
      value[builder.refreshToken?.as ?? "refreshToken"] ?? undefined;
    if (isPlainObject(value[builder.refreshToken?.as ?? "refreshToken"])) {
      const arr = [value[builder.refreshToken?.as ?? "refreshToken"]];
      transformSessionStoreToken(arr, builder.refreshToken);
      value[builder.refreshToken?.as ?? "refreshToken"] = arr[0];
    }
    value[builder.accessToken?.as ?? "accessToken"] =
      value[builder.accessToken?.as ?? "accessToken"] ?? undefined;
    if (isPlainObject(value[builder.accessToken?.as ?? "accessToken"])) {
      const arr = [value[builder.accessToken?.as ?? "accessToken"]];
      transformSessionStoreToken(arr, builder.accessToken);
      value[builder.accessToken?.as ?? "accessToken"] = arr[0];
    }
  }
}
