// Generated by @compas/code-gen
/* eslint-disable no-unused-vars */

import { query } from "@compas/store";
import {
  transformFile,
  transformFileGroup,
  transformFileGroupView,
  transformJob,
  transformSession,
} from "./query-builder.js";
import {
  fileFields,
  fileGroupFields,
  fileGroupInsertValues,
  fileGroupOrderBy,
  fileGroupUpdateSet,
  fileGroupViewFields,
  fileGroupViewOrderBy,
  fileGroupViewWhere,
  fileGroupWhere,
  fileInsertValues,
  fileOrderBy,
  fileUpdateSet,
  fileWhere,
  jobFields,
  jobInsertValues,
  jobOrderBy,
  jobUpdateSet,
  jobWhere,
  sessionFields,
  sessionInsertValues,
  sessionOrderBy,
  sessionUpdateSet,
  sessionWhere,
} from "./query-partials.js";
/**
 * @param {Postgres} sql
 * @param {StoreFileWhere} [where]
 * @returns {Promise<StoreFile[]>}
 */
export async function fileSelect(sql, where) {
  const result = await query`
SELECT ${fileFields()}
FROM "file" f
WHERE ${fileWhere(where)}
ORDER BY ${fileOrderBy()}
`.exec(sql);
  transformFile(result);
  return result;
}
/**
 * @param {Postgres} sql
 * @param {StoreFileWhere} [where]
 * @returns {Promise<number>}
 */
export async function fileCount(sql, where) {
  const [result] = await query`
SELECT COUNT(f."id") as "countResult"
FROM "file" f
WHERE ${fileWhere(where)}
`.exec(sql);
  return Number(result?.countResult ?? "0");
}
/**
 * @param {Postgres} sql
 * @param {StoreFileWhere} [where={}]
 * @returns {Promise<void>}
 */
export function fileDeletePermanent(sql, where = {}) {
  where.deletedAtIncludeNotNull = true;
  return query`
DELETE FROM "file" f
WHERE ${fileWhere(where)}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreFileInsertPartial|(StoreFileInsertPartial[])} insert
 * @param {{ withPrimaryKey: boolean }=} options
 * @returns {Promise<StoreFile[]>}
 */
export async function fileInsert(sql, insert, options = {}) {
  if (insert === undefined || insert.length === 0) {
    return [];
  }
  options.withPrimaryKey = options.withPrimaryKey ?? false;
  const result = await query`
INSERT INTO "file" (${fileFields("", {
    excludePrimaryKey: !options.withPrimaryKey,
  })})
VALUES ${fileInsertValues(insert, {
    includePrimaryKey: options.withPrimaryKey,
  })}
RETURNING ${fileFields("")}
`.exec(sql);
  transformFile(result);
  return result;
}
/**
 * @param {Postgres} sql
 * @param {StoreFileUpdatePartial} update
 * @param {StoreFileWhere} [where={}]
 * @returns {Promise<StoreFile[]>}
 */
export async function fileUpdate(sql, update, where = {}) {
  const result = await query`
UPDATE "file" f
SET ${fileUpdateSet(update)}
WHERE ${fileWhere(where)}
RETURNING ${fileFields()}
`.exec(sql);
  transformFile(result);
  return result;
}
/**
 * @param {Postgres} sql
 * @param {StoreFileWhere} [where={}]
 * @param {{ skipCascade: boolean }} [options={}]
 * @returns {Promise<void>}
 */
export async function fileDelete(sql, where = {}, options = {}) {
  const result = await query`
UPDATE "file" f
SET "deletedAt" = now()
WHERE ${fileWhere(where)}
RETURNING "id"
`.exec(sql);
  if (options.skipCascade || result.length === 0) {
    return;
  }
  const ids = result.map((it) => it.id);
  await Promise.all([fileGroupDelete(sql, { fileIn: ids })]);
}
/**
 * @param {Postgres} sql
 * @param {StoreFileGroupWhere} [where]
 * @returns {Promise<StoreFileGroup[]>}
 */
export async function fileGroupSelect(sql, where) {
  const result = await query`
SELECT ${fileGroupFields()}
FROM "fileGroup" fg
WHERE ${fileGroupWhere(where)}
ORDER BY ${fileGroupOrderBy()}
`.exec(sql);
  transformFileGroup(result);
  return result;
}
/**
 * @param {Postgres} sql
 * @param {StoreFileGroupWhere} [where]
 * @returns {Promise<number>}
 */
export async function fileGroupCount(sql, where) {
  const [result] = await query`
SELECT COUNT(fg."id") as "countResult"
FROM "fileGroup" fg
WHERE ${fileGroupWhere(where)}
`.exec(sql);
  return Number(result?.countResult ?? "0");
}
/**
 * @param {Postgres} sql
 * @param {StoreFileGroupWhere} [where={}]
 * @returns {Promise<void>}
 */
export function fileGroupDeletePermanent(sql, where = {}) {
  where.deletedAtIncludeNotNull = true;
  return query`
DELETE FROM "fileGroup" fg
WHERE ${fileGroupWhere(where)}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreFileGroupInsertPartial|(StoreFileGroupInsertPartial[])} insert
 * @param {{ withPrimaryKey: boolean }=} options
 * @returns {Promise<StoreFileGroup[]>}
 */
export async function fileGroupInsert(sql, insert, options = {}) {
  if (insert === undefined || insert.length === 0) {
    return [];
  }
  options.withPrimaryKey = options.withPrimaryKey ?? false;
  const result = await query`
INSERT INTO "fileGroup" (${fileGroupFields("", {
    excludePrimaryKey: !options.withPrimaryKey,
  })})
VALUES ${fileGroupInsertValues(insert, {
    includePrimaryKey: options.withPrimaryKey,
  })}
RETURNING ${fileGroupFields("")}
`.exec(sql);
  transformFileGroup(result);
  return result;
}
/**
 * @param {Postgres} sql
 * @param {StoreFileGroupUpdatePartial} update
 * @param {StoreFileGroupWhere} [where={}]
 * @returns {Promise<StoreFileGroup[]>}
 */
export async function fileGroupUpdate(sql, update, where = {}) {
  const result = await query`
UPDATE "fileGroup" fg
SET ${fileGroupUpdateSet(update)}
WHERE ${fileGroupWhere(where)}
RETURNING ${fileGroupFields()}
`.exec(sql);
  transformFileGroup(result);
  return result;
}
/**
 * @param {Postgres} sql
 * @param {StoreFileGroupWhere} [where={}]
 * @param {{ skipCascade: boolean }} [options={}]
 * @returns {Promise<void>}
 */
export async function fileGroupDelete(sql, where = {}, options = {}) {
  const result = await query`
UPDATE "fileGroup" fg
SET "deletedAt" = now()
WHERE ${fileGroupWhere(where)}
RETURNING "id"
`.exec(sql);
  if (options.skipCascade || result.length === 0) {
    return;
  }
  const ids = result.map((it) => it.id);
  await Promise.all([fileGroupDelete(sql, { parentIn: ids })]);
}
/**
 * @param {Postgres} sql
 * @param {StoreFileGroupViewWhere} [where]
 * @returns {Promise<StoreFileGroupView[]>}
 */
export async function fileGroupViewSelect(sql, where) {
  const result = await query`
SELECT ${fileGroupViewFields()}
FROM "fileGroupView" fgv
WHERE ${fileGroupViewWhere(where)}
ORDER BY ${fileGroupViewOrderBy()}
`.exec(sql);
  transformFileGroupView(result);
  return result;
}
/**
 * @param {Postgres} sql
 * @param {StoreFileGroupViewWhere} [where]
 * @returns {Promise<number>}
 */
export async function fileGroupViewCount(sql, where) {
  const [result] = await query`
SELECT COUNT(fgv."id") as "countResult"
FROM "fileGroupView" fgv
WHERE ${fileGroupViewWhere(where)}
`.exec(sql);
  return Number(result?.countResult ?? "0");
}
/**
 * @param {Postgres} sql
 * @param {StoreFileGroupViewWhere} [where={}]
 * @param {{ skipCascade: boolean }} [options={}]
 * @returns {Promise<void>}
 */
export async function fileGroupViewDelete(sql, where = {}, options = {}) {
  await query`
UPDATE "fileGroupView" fgv
SET "deletedAt" = now()
WHERE ${fileGroupViewWhere(where)}
RETURNING "id"
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreJobWhere} [where]
 * @returns {Promise<StoreJob[]>}
 */
export async function jobSelect(sql, where) {
  const result = await query`
SELECT ${jobFields()}
FROM "job" j
WHERE ${jobWhere(where)}
ORDER BY ${jobOrderBy()}
`.exec(sql);
  transformJob(result);
  return result;
}
/**
 * @param {Postgres} sql
 * @param {StoreJobWhere} [where]
 * @returns {Promise<number>}
 */
export async function jobCount(sql, where) {
  const [result] = await query`
SELECT COUNT(j."id") as "countResult"
FROM "job" j
WHERE ${jobWhere(where)}
`.exec(sql);
  return Number(result?.countResult ?? "0");
}
/**
 * @param {Postgres} sql
 * @param {StoreJobWhere} [where={}]
 * @returns {Promise<void>}
 */
export function jobDelete(sql, where = {}) {
  return query`
DELETE FROM "job" j
WHERE ${jobWhere(where)}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreJobInsertPartial|(StoreJobInsertPartial[])} insert
 * @param {{ withPrimaryKey: boolean }=} options
 * @returns {Promise<StoreJob[]>}
 */
export async function jobInsert(sql, insert, options = {}) {
  if (insert === undefined || insert.length === 0) {
    return [];
  }
  options.withPrimaryKey = options.withPrimaryKey ?? false;
  const result = await query`
INSERT INTO "job" (${jobFields("", {
    excludePrimaryKey: !options.withPrimaryKey,
  })})
VALUES ${jobInsertValues(insert, { includePrimaryKey: options.withPrimaryKey })}
RETURNING ${jobFields("")}
`.exec(sql);
  transformJob(result);
  return result;
}
/**
 * @param {Postgres} sql
 * @param {StoreJobUpdatePartial} update
 * @param {StoreJobWhere} [where={}]
 * @returns {Promise<StoreJob[]>}
 */
export async function jobUpdate(sql, update, where = {}) {
  const result = await query`
UPDATE "job" j
SET ${jobUpdateSet(update)}
WHERE ${jobWhere(where)}
RETURNING ${jobFields()}
`.exec(sql);
  transformJob(result);
  return result;
}
/**
 * @param {Postgres} sql
 * @param {StoreSessionWhere} [where]
 * @returns {Promise<StoreSession[]>}
 */
export async function sessionSelect(sql, where) {
  const result = await query`
SELECT ${sessionFields()}
FROM "session" s
WHERE ${sessionWhere(where)}
ORDER BY ${sessionOrderBy()}
`.exec(sql);
  transformSession(result);
  return result;
}
/**
 * @param {Postgres} sql
 * @param {StoreSessionWhere} [where]
 * @returns {Promise<number>}
 */
export async function sessionCount(sql, where) {
  const [result] = await query`
SELECT COUNT(s."id") as "countResult"
FROM "session" s
WHERE ${sessionWhere(where)}
`.exec(sql);
  return Number(result?.countResult ?? "0");
}
/**
 * @param {Postgres} sql
 * @param {StoreSessionWhere} [where={}]
 * @returns {Promise<void>}
 */
export function sessionDelete(sql, where = {}) {
  return query`
DELETE FROM "session" s
WHERE ${sessionWhere(where)}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreSessionInsertPartial|(StoreSessionInsertPartial[])} insert
 * @param {{ withPrimaryKey: boolean }=} options
 * @returns {Promise<StoreSession[]>}
 */
export async function sessionInsert(sql, insert, options = {}) {
  if (insert === undefined || insert.length === 0) {
    return [];
  }
  options.withPrimaryKey = options.withPrimaryKey ?? false;
  const result = await query`
INSERT INTO "session" (${sessionFields("", {
    excludePrimaryKey: !options.withPrimaryKey,
  })})
VALUES ${sessionInsertValues(insert, {
    includePrimaryKey: options.withPrimaryKey,
  })}
RETURNING ${sessionFields("")}
`.exec(sql);
  transformSession(result);
  return result;
}
/**
 * @param {Postgres} sql
 * @param {StoreSessionUpdatePartial} update
 * @param {StoreSessionWhere} [where={}]
 * @returns {Promise<StoreSession[]>}
 */
export async function sessionUpdate(sql, update, where = {}) {
  const result = await query`
UPDATE "session" s
SET ${sessionUpdateSet(update)}
WHERE ${sessionWhere(where)}
RETURNING ${sessionFields()}
`.exec(sql);
  transformSession(result);
  return result;
}
