// Generated by @lbu/code-gen
/* eslint-disable no-unused-vars */

import { query } from "@lbu/store";
import {
  fileFields,
  fileInsertValues,
  fileOrderBy,
  fileUpdateSet,
  fileWhere,
  jobFields,
  jobInsertValues,
  jobOrderBy,
  jobUpdateSet,
  jobWhere,
  sessionFields,
  sessionInsertValues,
  sessionOrderBy,
  sessionUpdateSet,
  sessionWhere,
} from "./query-partials.js";
/**
 * @param {Postgres} sql
 * @param {StoreFileWhere} [where]
 * @returns {Promise<StoreFile[]>}
 */
export function fileSelect(sql, where) {
  return query`
SELECT ${fileFields()}
FROM "file" f
WHERE ${fileWhere(where)}
ORDER BY ${fileOrderBy()}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreFileWhere} [where]
 * @returns {Promise<number>}
 */
export async function fileCount(sql, where) {
  const [result] = await query`
SELECT COUNT(f."id") as "countResult"
FROM "file" f
WHERE ${fileWhere(where)}
`.exec(sql);
  return Number(result?.countResult ?? "0");
}
/**
 * @param {Postgres} sql
 * @param {StoreFileWhere} [where={}]
 * @returns {Promise<void>}
 */
export function fileDeletePermanent(sql, where = {}) {
  where.deletedAtIncludeNotNull = true;
  return query`
DELETE FROM "file" f
WHERE ${fileWhere(where)}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreFileInsertPartial|(StoreFileInsertPartial[])} insert
 * @returns {Promise<StoreFile[]>}
 */
export function fileInsert(sql, insert) {
  return query`
INSERT INTO "file" (${fileFields("", { excludePrimaryKey: true })})
VALUES ${fileInsertValues(insert)}
RETURNING ${fileFields("")}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreFileUpdatePartial} update
 * @param {StoreFileWhere} [where={}]
 * @returns {Promise<StoreFile[]>}
 */
export function fileUpdate(sql, update, where = {}) {
  return query`
UPDATE "file" f
SET ${fileUpdateSet(update)}
WHERE ${fileWhere(where)}
RETURNING ${fileFields()}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreFileWhere} [where={}]
 * @param {{ skipCascade: boolean }} [options={}]
 * @returns {Promise<void>}
 */
export async function fileDelete(sql, where = {}, options = {}) {
  await query`
UPDATE "file" f
SET "deletedAt" = now()
WHERE ${fileWhere(where)}
RETURNING "id"
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreJobWhere} [where]
 * @returns {Promise<StoreJob[]>}
 */
export function jobSelect(sql, where) {
  return query`
SELECT ${jobFields()}
FROM "job" j
WHERE ${jobWhere(where)}
ORDER BY ${jobOrderBy()}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreJobWhere} [where]
 * @returns {Promise<number>}
 */
export async function jobCount(sql, where) {
  const [result] = await query`
SELECT COUNT(j."id") as "countResult"
FROM "job" j
WHERE ${jobWhere(where)}
`.exec(sql);
  return Number(result?.countResult ?? "0");
}
/**
 * @param {Postgres} sql
 * @param {StoreJobWhere} [where={}]
 * @returns {Promise<void>}
 */
export function jobDelete(sql, where = {}) {
  return query`
DELETE FROM "job" j
WHERE ${jobWhere(where)}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreJobInsertPartial|(StoreJobInsertPartial[])} insert
 * @returns {Promise<StoreJob[]>}
 */
export function jobInsert(sql, insert) {
  return query`
INSERT INTO "job" (${jobFields("", { excludePrimaryKey: true })})
VALUES ${jobInsertValues(insert)}
RETURNING ${jobFields("")}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreJobUpdatePartial} update
 * @param {StoreJobWhere} [where={}]
 * @returns {Promise<StoreJob[]>}
 */
export function jobUpdate(sql, update, where = {}) {
  return query`
UPDATE "job" j
SET ${jobUpdateSet(update)}
WHERE ${jobWhere(where)}
RETURNING ${jobFields()}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreSessionWhere} [where]
 * @returns {Promise<StoreSession[]>}
 */
export function sessionSelect(sql, where) {
  return query`
SELECT ${sessionFields()}
FROM "session" s
WHERE ${sessionWhere(where)}
ORDER BY ${sessionOrderBy()}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreSessionWhere} [where]
 * @returns {Promise<number>}
 */
export async function sessionCount(sql, where) {
  const [result] = await query`
SELECT COUNT(s."id") as "countResult"
FROM "session" s
WHERE ${sessionWhere(where)}
`.exec(sql);
  return Number(result?.countResult ?? "0");
}
/**
 * @param {Postgres} sql
 * @param {StoreSessionWhere} [where={}]
 * @returns {Promise<void>}
 */
export function sessionDelete(sql, where = {}) {
  return query`
DELETE FROM "session" s
WHERE ${sessionWhere(where)}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreSessionInsertPartial|(StoreSessionInsertPartial[])} insert
 * @returns {Promise<StoreSession[]>}
 */
export function sessionInsert(sql, insert) {
  return query`
INSERT INTO "session" (${sessionFields("", { excludePrimaryKey: true })})
VALUES ${sessionInsertValues(insert)}
RETURNING ${sessionFields("")}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreSessionUpdatePartial} update
 * @param {StoreSessionWhere} [where={}]
 * @returns {Promise<StoreSession[]>}
 */
export function sessionUpdate(sql, update, where = {}) {
  return query`
UPDATE "session" s
SET ${sessionUpdateSet(update)}
WHERE ${sessionWhere(where)}
RETURNING ${sessionFields()}
`.exec(sql);
}
