// Generated by @lbu/code-gen
/* eslint-disable no-unused-vars */

import { query } from "@lbu/store";
import {
  fileFields,
  fileGroupFields,
  fileGroupInsertValues,
  fileGroupOrderBy,
  fileGroupUpdateSet,
  fileGroupViewFields,
  fileGroupViewOrderBy,
  fileGroupViewWhere,
  fileGroupWhere,
  fileInsertValues,
  fileOrderBy,
  fileUpdateSet,
  fileWhere,
  jobFields,
  jobInsertValues,
  jobOrderBy,
  jobUpdateSet,
  jobWhere,
  sessionFields,
  sessionInsertValues,
  sessionOrderBy,
  sessionUpdateSet,
  sessionWhere,
} from "./query-partials.js";
/**
 * @param {Postgres} sql
 * @param {StoreFileWhere} [where]
 * @returns {Promise<StoreFile[]>}
 */
export function fileSelect(sql, where) {
  return query`
SELECT ${fileFields()}
FROM "file" f
WHERE ${fileWhere(where)}
ORDER BY ${fileOrderBy()}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreFileWhere} [where]
 * @returns {Promise<number>}
 */
export async function fileCount(sql, where) {
  const [result] = await query`
SELECT COUNT(f."id") as "countResult"
FROM "file" f
WHERE ${fileWhere(where)}
`.exec(sql);
  return Number(result?.countResult ?? "0");
}
/**
 * @param {Postgres} sql
 * @param {StoreFileWhere} [where={}]
 * @returns {Promise<void>}
 */
export function fileDeletePermanent(sql, where = {}) {
  where.deletedAtIncludeNotNull = true;
  return query`
DELETE FROM "file" f
WHERE ${fileWhere(where)}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreFileInsertPartial|(StoreFileInsertPartial[])} insert
 * @returns {Promise<StoreFile[]>}
 */
export function fileInsert(sql, insert) {
  if (insert === undefined || insert.length === 0) {
    return [];
  }
  return query`
INSERT INTO "file" (${fileFields("", { excludePrimaryKey: true })})
VALUES ${fileInsertValues(insert)}
RETURNING ${fileFields("")}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreFileUpdatePartial} update
 * @param {StoreFileWhere} [where={}]
 * @returns {Promise<StoreFile[]>}
 */
export function fileUpdate(sql, update, where = {}) {
  return query`
UPDATE "file" f
SET ${fileUpdateSet(update)}
WHERE ${fileWhere(where)}
RETURNING ${fileFields()}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreFileWhere} [where={}]
 * @param {{ skipCascade: boolean }} [options={}]
 * @returns {Promise<void>}
 */
export async function fileDelete(sql, where = {}, options = {}) {
  const result = await query`
UPDATE "file" f
SET "deletedAt" = now()
WHERE ${fileWhere(where)}
RETURNING "id"
`.exec(sql);
  if (options.skipCascade || result.length === 0) {
    return;
  }
  const ids = result.map((it) => it.id);
  await Promise.all([fileGroupDelete(sql, { fileIn: ids })]);
}
/**
 * @param {Postgres} sql
 * @param {StoreFileGroupWhere} [where]
 * @returns {Promise<StoreFileGroup[]>}
 */
export function fileGroupSelect(sql, where) {
  return query`
SELECT ${fileGroupFields()}
FROM "fileGroup" fg
WHERE ${fileGroupWhere(where)}
ORDER BY ${fileGroupOrderBy()}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreFileGroupWhere} [where]
 * @returns {Promise<number>}
 */
export async function fileGroupCount(sql, where) {
  const [result] = await query`
SELECT COUNT(fg."id") as "countResult"
FROM "fileGroup" fg
WHERE ${fileGroupWhere(where)}
`.exec(sql);
  return Number(result?.countResult ?? "0");
}
/**
 * @param {Postgres} sql
 * @param {StoreFileGroupWhere} [where={}]
 * @returns {Promise<void>}
 */
export function fileGroupDeletePermanent(sql, where = {}) {
  where.deletedAtIncludeNotNull = true;
  return query`
DELETE FROM "fileGroup" fg
WHERE ${fileGroupWhere(where)}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreFileGroupInsertPartial|(StoreFileGroupInsertPartial[])} insert
 * @returns {Promise<StoreFileGroup[]>}
 */
export function fileGroupInsert(sql, insert) {
  if (insert === undefined || insert.length === 0) {
    return [];
  }
  return query`
INSERT INTO "fileGroup" (${fileGroupFields("", { excludePrimaryKey: true })})
VALUES ${fileGroupInsertValues(insert)}
RETURNING ${fileGroupFields("")}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreFileGroupUpdatePartial} update
 * @param {StoreFileGroupWhere} [where={}]
 * @returns {Promise<StoreFileGroup[]>}
 */
export function fileGroupUpdate(sql, update, where = {}) {
  return query`
UPDATE "fileGroup" fg
SET ${fileGroupUpdateSet(update)}
WHERE ${fileGroupWhere(where)}
RETURNING ${fileGroupFields()}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreFileGroupWhere} [where={}]
 * @param {{ skipCascade: boolean }} [options={}]
 * @returns {Promise<void>}
 */
export async function fileGroupDelete(sql, where = {}, options = {}) {
  const result = await query`
UPDATE "fileGroup" fg
SET "deletedAt" = now()
WHERE ${fileGroupWhere(where)}
RETURNING "id"
`.exec(sql);
  if (options.skipCascade || result.length === 0) {
    return;
  }
  const ids = result.map((it) => it.id);
  await Promise.all([fileGroupDelete(sql, { parentIn: ids })]);
}
/**
 * @param {Postgres} sql
 * @param {StoreFileGroupViewWhere} [where]
 * @returns {Promise<StoreFileGroupView[]>}
 */
export function fileGroupViewSelect(sql, where) {
  return query`
SELECT ${fileGroupViewFields()}
FROM "fileGroupView" fgv
WHERE ${fileGroupViewWhere(where)}
ORDER BY ${fileGroupViewOrderBy()}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreFileGroupViewWhere} [where]
 * @returns {Promise<number>}
 */
export async function fileGroupViewCount(sql, where) {
  const [result] = await query`
SELECT COUNT(fgv."id") as "countResult"
FROM "fileGroupView" fgv
WHERE ${fileGroupViewWhere(where)}
`.exec(sql);
  return Number(result?.countResult ?? "0");
}
/**
 * @param {Postgres} sql
 * @param {StoreFileGroupViewWhere} [where={}]
 * @param {{ skipCascade: boolean }} [options={}]
 * @returns {Promise<void>}
 */
export async function fileGroupViewDelete(sql, where = {}, options = {}) {
  await query`
UPDATE "fileGroupView" fgv
SET "deletedAt" = now()
WHERE ${fileGroupViewWhere(where)}
RETURNING "id"
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreJobWhere} [where]
 * @returns {Promise<StoreJob[]>}
 */
export function jobSelect(sql, where) {
  return query`
SELECT ${jobFields()}
FROM "job" j
WHERE ${jobWhere(where)}
ORDER BY ${jobOrderBy()}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreJobWhere} [where]
 * @returns {Promise<number>}
 */
export async function jobCount(sql, where) {
  const [result] = await query`
SELECT COUNT(j."id") as "countResult"
FROM "job" j
WHERE ${jobWhere(where)}
`.exec(sql);
  return Number(result?.countResult ?? "0");
}
/**
 * @param {Postgres} sql
 * @param {StoreJobWhere} [where={}]
 * @returns {Promise<void>}
 */
export function jobDelete(sql, where = {}) {
  return query`
DELETE FROM "job" j
WHERE ${jobWhere(where)}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreJobInsertPartial|(StoreJobInsertPartial[])} insert
 * @returns {Promise<StoreJob[]>}
 */
export function jobInsert(sql, insert) {
  if (insert === undefined || insert.length === 0) {
    return [];
  }
  return query`
INSERT INTO "job" (${jobFields("", { excludePrimaryKey: true })})
VALUES ${jobInsertValues(insert)}
RETURNING ${jobFields("")}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreJobUpdatePartial} update
 * @param {StoreJobWhere} [where={}]
 * @returns {Promise<StoreJob[]>}
 */
export function jobUpdate(sql, update, where = {}) {
  return query`
UPDATE "job" j
SET ${jobUpdateSet(update)}
WHERE ${jobWhere(where)}
RETURNING ${jobFields()}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreSessionWhere} [where]
 * @returns {Promise<StoreSession[]>}
 */
export function sessionSelect(sql, where) {
  return query`
SELECT ${sessionFields()}
FROM "session" s
WHERE ${sessionWhere(where)}
ORDER BY ${sessionOrderBy()}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreSessionWhere} [where]
 * @returns {Promise<number>}
 */
export async function sessionCount(sql, where) {
  const [result] = await query`
SELECT COUNT(s."id") as "countResult"
FROM "session" s
WHERE ${sessionWhere(where)}
`.exec(sql);
  return Number(result?.countResult ?? "0");
}
/**
 * @param {Postgres} sql
 * @param {StoreSessionWhere} [where={}]
 * @returns {Promise<void>}
 */
export function sessionDelete(sql, where = {}) {
  return query`
DELETE FROM "session" s
WHERE ${sessionWhere(where)}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreSessionInsertPartial|(StoreSessionInsertPartial[])} insert
 * @returns {Promise<StoreSession[]>}
 */
export function sessionInsert(sql, insert) {
  if (insert === undefined || insert.length === 0) {
    return [];
  }
  return query`
INSERT INTO "session" (${sessionFields("", { excludePrimaryKey: true })})
VALUES ${sessionInsertValues(insert)}
RETURNING ${sessionFields("")}
`.exec(sql);
}
/**
 * @param {Postgres} sql
 * @param {StoreSessionUpdatePartial} update
 * @param {StoreSessionWhere} [where={}]
 * @returns {Promise<StoreSession[]>}
 */
export function sessionUpdate(sql, update, where = {}) {
  return query`
UPDATE "session" s
SET ${sessionUpdateSet(update)}
WHERE ${sessionWhere(where)}
RETURNING ${sessionFields()}
`.exec(sql);
}
