// Generated by @lbu/code-gen
/* eslint-disable no-unused-vars */

import { uuid } from "@lbu/stdlib";

export const storeQueries = {
  /**
   * @param sql
   * @param { StoreFileStoreWhere} where
   * @returns {Promise<StoreFileStore[]>}
   */
  fileStoreSelect: (
    sql,
    where,
  ) => sql`SELECT fs."id", fs."bucketName", fs."contentLength", fs."contentType", fs."filename", fs."createdAt", fs."updatedAt" FROM "fileStore" fs 
WHERE (COALESCE(${where.id}, NULL) IS NULL OR fs."id" = ${
    where.id
  }) AND (COALESCE(${where.idIn}, NULL) IS NULL OR fs."id" = ANY (${sql.array(
    where?.idIn ?? [],
  )}::uuid[])) AND (COALESCE(${
    where.bucketName
  }, NULL) IS NULL OR fs."bucketName" = ${where.bucketName}) AND (COALESCE(${
    where.bucketNameLike
  }, NULL) IS NULL OR fs."bucketName" LIKE ${"%" + where.bucketNameLike + "%"})
`,

  /**
   * @param sql
   * @param { StoreFileStoreWhere} where
   * @returns {Promise<number>}
   */
  fileStoreCount: async (sql, where) => {
    const result = await sql`SELECT count(*) as "genCount" FROM "fileStore" fs 
WHERE (COALESCE(${where.id}, NULL) IS NULL OR fs."id" = ${
      where.id
    }) AND (COALESCE(${where.idIn}, NULL) IS NULL OR fs."id" = ANY (${sql.array(
      where?.idIn ?? [],
    )}::uuid[])) AND (COALESCE(${
      where.bucketName
    }, NULL) IS NULL OR fs."bucketName" = ${where.bucketName}) AND (COALESCE(${
      where.bucketNameLike
    }, NULL) IS NULL OR fs."bucketName" LIKE ${
      "%" + where.bucketNameLike + "%"
    })
`;
    return result?.[0]?.genCount ?? 0;
  },

  /**
   * @param sql
   * @param { StoreFileStoreWhere} where
   * @returns {Promise<*[]>}
   */
  fileStoreDelete: (sql, where) => sql`DELETE FROM "fileStore" fs 
WHERE (COALESCE(${where.id}, NULL) IS NULL OR fs."id" = ${
    where.id
  }) AND (COALESCE(${where.idIn}, NULL) IS NULL OR fs."id" = ANY (${sql.array(
    where?.idIn ?? [],
  )}::uuid[])) AND (COALESCE(${
    where.bucketName
  }, NULL) IS NULL OR fs."bucketName" = ${where.bucketName}) AND (COALESCE(${
    where.bucketNameLike
  }, NULL) IS NULL OR fs."bucketName" LIKE ${"%" + where.bucketNameLike + "%"})
`,

  /**
   * @param sql
   * @param { StoreFileStoreInsertPartial_Input|StoreFileStoreInsertPartial_Input[]} insert
   * @returns {Promise<StoreFileStore[]>}
   */
  fileStoreInsert: (sql, insert) => {
    const data = Array.isArray(insert) ? insert : [insert];
    const input = [];
    for (const it of data) {
      input.push({
        bucketName: it.bucketName ?? undefined,
        contentLength: it.contentLength ?? undefined,
        contentType: it.contentType ?? undefined,
        filename: it.filename ?? undefined,
        createdAt: it.createdAt ?? new Date(),
        updatedAt: it.updatedAt ?? new Date(),
      });
    }

    if (input.length === 0) {
      return [];
    }

    let query = `INSERT INTO "fileStore" ("bucketName", "contentLength", "contentType", "filename", "createdAt", "updatedAt") VALUES `;
    const argList = [];
    let idx = 1;
    for (const item of input) {
      argList.push(
        item.bucketName,
        item.contentLength,
        item.contentType,
        item.filename,
        item.createdAt,
        item.updatedAt,
      );
      query += `($${idx++}, $${idx++}, $${idx++}, $${idx++}, $${idx++}, $${idx++}),`;
    }
    // Remove trailing comma
    query = query.substring(0, query.length - 1);
    query += ` RETURNING "id", "bucketName", "contentLength", "contentType", "filename", "createdAt", "updatedAt"`;
    return sql.unsafe(query, argList);
  },

  /**
   * @param sql
   * @param { StoreFileStoreInsertPartial_Input} value
   * @param { StoreFileStoreWhere} where
   * @returns {Promise<StoreFileStore[]>}
   */
  fileStoreUpdate: async (sql, value, where) => {
    const updateValue = { ...value };
    updateValue.updatedAt = new Date();

    await sql`INSERT INTO "fileStoreHistory" ("fileStoreId", "bucketName", "contentLength", "contentType", "filename", "createdAt", "updatedAt", "createdAt")
    SELECT id, "bucketName", "contentLength", "contentType", "filename", "createdAt", "updatedAt", COALESCE("updatedAt", "createdAt", now()) FROM "fileStore" fs
    WHERE (COALESCE(${where.id}, NULL) IS NULL OR fs."id" = ${
      where.id
    }) AND (COALESCE(${where.idIn}, NULL) IS NULL OR fs."id" = ANY (${sql.array(
      where?.idIn ?? [],
    )}::uuid[])) AND (COALESCE(${
      where.bucketName
    }, NULL) IS NULL OR fs."bucketName" = ${where.bucketName}) AND (COALESCE(${
      where.bucketNameLike
    }, NULL) IS NULL OR fs."bucketName" LIKE ${
      "%" + where.bucketNameLike + "%"
    })
    `;
    return sql`UPDATE "fileStore" fs set ${sql(
      updateValue,
      ...Object.keys(updateValue),
    )} 
WHERE (COALESCE(${where.id}, NULL) IS NULL OR fs."id" = ${
      where.id
    }) AND (COALESCE(${where.idIn}, NULL) IS NULL OR fs."id" = ANY (${sql.array(
      where?.idIn ?? [],
    )}::uuid[])) AND (COALESCE(${
      where.bucketName
    }, NULL) IS NULL OR fs."bucketName" = ${where.bucketName}) AND (COALESCE(${
      where.bucketNameLike
    }, NULL) IS NULL OR fs."bucketName" LIKE ${
      "%" + where.bucketNameLike + "%"
    })
RETURNING fs."id", fs."bucketName", fs."contentLength", fs."contentType", fs."filename", fs."createdAt", fs."updatedAt"`;
  },

  /**
   * @param sql
   * @param { StoreFileStoreWhere} where
   * @returns {Promise<(StoreFileStore & (history: StoreFileStore[]))[]>}
   */
  fileStoreSelectHistory: (
    sql,
    where,
  ) => sql`SELECT fs."id", fs."bucketName", fs."contentLength", fs."contentType", fs."filename", fs."createdAt", fs."updatedAt", array_agg(fsh.*) as history FROM "fileStore" fs LEFT JOIN "fileStoreHistory" fsh ON fs.id = fsh."fileStoreId" 
WHERE (COALESCE(${where.id}, NULL) IS NULL OR fs."id" = ${
    where.id
  }) AND (COALESCE(${where.idIn}, NULL) IS NULL OR fs."id" = ANY (${sql.array(
    where?.idIn ?? [],
  )}::uuid[])) AND (COALESCE(${
    where.bucketName
  }, NULL) IS NULL OR fs."bucketName" = ${where.bucketName}) AND (COALESCE(${
    where.bucketNameLike
  }, NULL) IS NULL OR fs."bucketName" LIKE ${"%" + where.bucketNameLike + "%"})
GROUP BY fs.id`,

  /**
   * @param sql
   * @param { StoreSessionStoreWhere} where
   * @returns {Promise<StoreSessionStore[]>}
   */
  sessionStoreSelect: (
    sql,
    where,
  ) => sql`SELECT ss."id", ss."expires", ss."data", ss."createdAt", ss."updatedAt" FROM "sessionStore" ss 
WHERE (COALESCE(${where.id}, NULL) IS NULL OR ss."id" = ${
    where.id
  }) AND (COALESCE(${where.idIn}, NULL) IS NULL OR ss."id" = ANY (${sql.array(
    where?.idIn ?? [],
  )}::uuid[])) AND (COALESCE(${
    where.expires
  }, NULL) IS NULL OR ss."expires" = ${where.expires}) AND (COALESCE(${
    where.expiresGreaterThan
  }, NULL) IS NULL OR ss."expires" > ${
    where.expiresGreaterThan
  }) AND (COALESCE(${where.expiresLowerThan}, NULL) IS NULL OR ss."expires" < ${
    where.expiresLowerThan
  })
`,

  /**
   * @param sql
   * @param { StoreSessionStoreWhere} where
   * @returns {Promise<number>}
   */
  sessionStoreCount: async (sql, where) => {
    const result = await sql`SELECT count(*) as "genCount" FROM "sessionStore" ss 
WHERE (COALESCE(${where.id}, NULL) IS NULL OR ss."id" = ${
      where.id
    }) AND (COALESCE(${where.idIn}, NULL) IS NULL OR ss."id" = ANY (${sql.array(
      where?.idIn ?? [],
    )}::uuid[])) AND (COALESCE(${
      where.expires
    }, NULL) IS NULL OR ss."expires" = ${where.expires}) AND (COALESCE(${
      where.expiresGreaterThan
    }, NULL) IS NULL OR ss."expires" > ${
      where.expiresGreaterThan
    }) AND (COALESCE(${
      where.expiresLowerThan
    }, NULL) IS NULL OR ss."expires" < ${where.expiresLowerThan})
`;
    return result?.[0]?.genCount ?? 0;
  },

  /**
   * @param sql
   * @param { StoreSessionStoreWhere} where
   * @returns {Promise<*[]>}
   */
  sessionStoreDelete: (sql, where) => sql`DELETE FROM "sessionStore" ss 
WHERE (COALESCE(${where.id}, NULL) IS NULL OR ss."id" = ${
    where.id
  }) AND (COALESCE(${where.idIn}, NULL) IS NULL OR ss."id" = ANY (${sql.array(
    where?.idIn ?? [],
  )}::uuid[])) AND (COALESCE(${
    where.expires
  }, NULL) IS NULL OR ss."expires" = ${where.expires}) AND (COALESCE(${
    where.expiresGreaterThan
  }, NULL) IS NULL OR ss."expires" > ${
    where.expiresGreaterThan
  }) AND (COALESCE(${where.expiresLowerThan}, NULL) IS NULL OR ss."expires" < ${
    where.expiresLowerThan
  })
`,

  /**
   * @param sql
   * @param { StoreSessionStoreInsertPartial_Input|StoreSessionStoreInsertPartial_Input[]} insert
   * @returns {Promise<StoreSessionStore[]>}
   */
  sessionStoreInsert: (sql, insert) => {
    const data = Array.isArray(insert) ? insert : [insert];
    const input = [];
    for (const it of data) {
      input.push({
        expires: it.expires ?? undefined,
        data: JSON.stringify(it.data ?? {}),
        createdAt: it.createdAt ?? new Date(),
        updatedAt: it.updatedAt ?? new Date(),
      });
    }
    if (input.length === 0) {
      return [];
    }
    let query = `INSERT INTO "sessionStore" ("expires", "data", "createdAt", "updatedAt") VALUES `;
    const argList = [];
    let idx = 1;
    for (const item of input) {
      argList.push(item.expires, item.data, item.createdAt, item.updatedAt);
      query += `($${idx++}, $${idx++}, $${idx++}, $${idx++}),`;
    }
    // Remove trailing comma
    query = query.substring(0, query.length - 1);
    query += ` RETURNING "id", "expires", "data", "createdAt", "updatedAt"`;
    return sql.unsafe(query, argList);
  },

  /**
   * @param sql
   * @param { StoreSessionStoreInsertPartial_Input} value
   * @param { StoreSessionStoreWhere} where
   * @returns {Promise<StoreSessionStore[]>}
   */
  sessionStoreUpdate: (sql, value, where) => {
    const updateValue = {};
    if (value["expires"] !== undefined) {
      updateValue["expires"] = value["expires"];
    }
    if (value["data"] !== undefined) {
      updateValue["data"] = JSON.stringify(value["data"]);
    }
    if (value["createdAt"] !== undefined) {
      updateValue["createdAt"] = value["createdAt"];
    }
    if (value["updatedAt"] !== undefined) {
      updateValue["updatedAt"] = value["updatedAt"];
    }
    updateValue.updatedAt = new Date();
    return sql`UPDATE "sessionStore" ss set ${sql(
      updateValue,
      ...Object.keys(updateValue),
    )} 
WHERE (COALESCE(${where.id}, NULL) IS NULL OR ss."id" = ${
      where.id
    }) AND (COALESCE(${where.idIn}, NULL) IS NULL OR ss."id" = ANY (${sql.array(
      where?.idIn ?? [],
    )}::uuid[])) AND (COALESCE(${
      where.expires
    }, NULL) IS NULL OR ss."expires" = ${where.expires}) AND (COALESCE(${
      where.expiresGreaterThan
    }, NULL) IS NULL OR ss."expires" > ${
      where.expiresGreaterThan
    }) AND (COALESCE(${
      where.expiresLowerThan
    }, NULL) IS NULL OR ss."expires" < ${where.expiresLowerThan})
RETURNING ss."id", ss."expires", ss."data", ss."createdAt", ss."updatedAt"`;
  },

  /**
   * Note: Use only when id has a unique constraint
   * @param sql
   * @param { StoreSessionStoreInsertPartial_Input & { id?: string } } it
   * @returns {Promise<StoreSessionStore[]>}
   */
  sessionStoreUpsert: (sql, it) => {
    const data = {
      expires: it.expires ?? undefined,
      data: JSON.stringify(it.data ?? {}),
      createdAt: it.createdAt ?? new Date(),
      updatedAt: it.updatedAt ?? new Date(),
    };
    data.id = it.id || uuid();
    return sql`INSERT INTO "sessionStore" ${sql(
      data,
      "id",
      "expires",
      "data",
      "createdAt",
      "updatedAt",
    )} ON CONFLICT ("id") DO UPDATE SET expires = EXCLUDED.expires, data = EXCLUDED.data, updatedAt = EXCLUDED.updatedAt RETURNING "id", "expires", "data", "createdAt", "updatedAt"`;
  },

  /**
   * Note: Use only when expires has a unique constraint
   * @param sql
   * @param { StoreSessionStoreInsertPartial_Input & { id?: string } } it
   * @returns {Promise<StoreSessionStore[]>}
   */
  sessionStoreUpsertByExpires: (sql, it) => {
    const data = {
      expires: it.expires ?? undefined,
      data: JSON.stringify(it.data ?? {}),
      createdAt: it.createdAt ?? new Date(),
      updatedAt: it.updatedAt ?? new Date(),
    };
    data.id = it.id || uuid();
    return sql`INSERT INTO "sessionStore" ${sql(
      data,
      "id",
      "expires",
      "data",
      "createdAt",
      "updatedAt",
    )} ON CONFLICT ("expires") DO UPDATE SET data = EXCLUDED.data, updatedAt = EXCLUDED.updatedAt RETURNING "id", "expires", "data", "createdAt", "updatedAt"`;
  },

  /**
   * @param sql
   * @param { StoreJobQueueWhere} where
   * @returns {Promise<StoreJobQueue[]>}
   */
  jobQueueSelect: (
    sql,
    where,
  ) => sql`SELECT jq."id", jq."isComplete", jq."priority", jq."scheduledAt", jq."name", jq."data", jq."createdAt", jq."updatedAt" FROM "jobQueue" jq 
WHERE (COALESCE(${where.id}, NULL) IS NULL OR jq."id" = ${
    where.id
  }) AND (COALESCE(${where.idGreaterThan}, NULL) IS NULL OR jq."id" > ${
    where.idGreaterThan
  }) AND (COALESCE(${where.idLowerThan}, NULL) IS NULL OR jq."id" < ${
    where.idLowerThan
  }) AND (COALESCE(${where.name}, NULL) IS NULL OR jq."name" = ${
    where.name
  }) AND (COALESCE(${where.nameLike}, NULL) IS NULL OR jq."name" LIKE ${
    "%" + where.nameLike + "%"
  })
`,

  /**
   * @param sql
   * @param { StoreJobQueueWhere} where
   * @returns {Promise<number>}
   */
  jobQueueCount: async (sql, where) => {
    const result = await sql`SELECT count(*) as "genCount" FROM "jobQueue" jq 
WHERE (COALESCE(${where.id}, NULL) IS NULL OR jq."id" = ${
      where.id
    }) AND (COALESCE(${where.idGreaterThan}, NULL) IS NULL OR jq."id" > ${
      where.idGreaterThan
    }) AND (COALESCE(${where.idLowerThan}, NULL) IS NULL OR jq."id" < ${
      where.idLowerThan
    }) AND (COALESCE(${where.name}, NULL) IS NULL OR jq."name" = ${
      where.name
    }) AND (COALESCE(${where.nameLike}, NULL) IS NULL OR jq."name" LIKE ${
      "%" + where.nameLike + "%"
    })
`;
    return result?.[0]?.genCount ?? 0;
  },

  /**
   * @param sql
   * @param { StoreJobQueueWhere} where
   * @returns {Promise<*[]>}
   */
  jobQueueDelete: (sql, where) => sql`DELETE FROM "jobQueue" jq 
WHERE (COALESCE(${where.id}, NULL) IS NULL OR jq."id" = ${
    where.id
  }) AND (COALESCE(${where.idGreaterThan}, NULL) IS NULL OR jq."id" > ${
    where.idGreaterThan
  }) AND (COALESCE(${where.idLowerThan}, NULL) IS NULL OR jq."id" < ${
    where.idLowerThan
  }) AND (COALESCE(${where.name}, NULL) IS NULL OR jq."name" = ${
    where.name
  }) AND (COALESCE(${where.nameLike}, NULL) IS NULL OR jq."name" LIKE ${
    "%" + where.nameLike + "%"
  })
`,

  /**
   * @param sql
   * @param { StoreJobQueueInsertPartial_Input|StoreJobQueueInsertPartial_Input[]} insert
   * @returns {Promise<StoreJobQueue[]>}
   */
  jobQueueInsert: (sql, insert) => {
    const data = Array.isArray(insert) ? insert : [insert];
    const input = [];
    for (const it of data) {
      input.push({
        isComplete: it.isComplete ?? false,
        priority: it.priority ?? 0,
        scheduledAt: it.scheduledAt ?? new Date(),
        name: it.name ?? undefined,
        data: JSON.stringify(it.data ?? {}),
        createdAt: it.createdAt ?? new Date(),
        updatedAt: it.updatedAt ?? new Date(),
      });
    }
    if (input.length === 0) {
      return [];
    }
    let query = `INSERT INTO "jobQueue" ("isComplete", "priority", "scheduledAt", "name", "data", "createdAt", "updatedAt") VALUES `;
    const argList = [];
    let idx = 1;
    for (const item of input) {
      argList.push(
        item.isComplete,
        item.priority,
        item.scheduledAt,
        item.name,
        item.data,
        item.createdAt,
        item.updatedAt,
      );
      query += `($${idx++}, $${idx++}, $${idx++}, $${idx++}, $${idx++}, $${idx++}, $${idx++}),`;
    }
    // Remove trailing comma
    query = query.substring(0, query.length - 1);
    query += ` RETURNING "id", "isComplete", "priority", "scheduledAt", "name", "data", "createdAt", "updatedAt"`;
    return sql.unsafe(query, argList);
  },

  /**
   * @param sql
   * @param { StoreJobQueueInsertPartial_Input} value
   * @param { StoreJobQueueWhere} where
   * @returns {Promise<StoreJobQueue[]>}
   */
  jobQueueUpdate: (sql, value, where) => {
    const updateValue = {};
    if (value["isComplete"] !== undefined) {
      updateValue["isComplete"] = value["isComplete"];
    }
    if (value["priority"] !== undefined) {
      updateValue["priority"] = value["priority"];
    }
    if (value["scheduledAt"] !== undefined) {
      updateValue["scheduledAt"] = value["scheduledAt"];
    }
    if (value["name"] !== undefined) {
      updateValue["name"] = value["name"];
    }
    if (value["data"] !== undefined) {
      updateValue["data"] = JSON.stringify(value["data"]);
    }
    if (value["createdAt"] !== undefined) {
      updateValue["createdAt"] = value["createdAt"];
    }
    if (value["updatedAt"] !== undefined) {
      updateValue["updatedAt"] = value["updatedAt"];
    }
    updateValue.updatedAt = new Date();
    return sql`UPDATE "jobQueue" jq set ${sql(
      updateValue,
      ...Object.keys(updateValue),
    )} 
WHERE (COALESCE(${where.id}, NULL) IS NULL OR jq."id" = ${
      where.id
    }) AND (COALESCE(${where.idGreaterThan}, NULL) IS NULL OR jq."id" > ${
      where.idGreaterThan
    }) AND (COALESCE(${where.idLowerThan}, NULL) IS NULL OR jq."id" < ${
      where.idLowerThan
    }) AND (COALESCE(${where.name}, NULL) IS NULL OR jq."name" = ${
      where.name
    }) AND (COALESCE(${where.nameLike}, NULL) IS NULL OR jq."name" LIKE ${
      "%" + where.nameLike + "%"
    })
RETURNING jq."id", jq."isComplete", jq."priority", jq."scheduledAt", jq."name", jq."data", jq."createdAt", jq."updatedAt"`;
  },

  /**
   * Note: Use only when id has a unique constraint
   * @param sql
   * @param { StoreJobQueueInsertPartial_Input & { id?: number } } it
   * @returns {Promise<StoreJobQueue[]>}
   */
  jobQueueUpsert: (sql, it) => {
    const data = {
      isComplete: it.isComplete ?? false,
      priority: it.priority ?? 0,
      scheduledAt: it.scheduledAt ?? new Date(),
      name: it.name ?? undefined,
      data: JSON.stringify(it.data ?? {}),
      createdAt: it.createdAt ?? new Date(),
      updatedAt: it.updatedAt ?? new Date(),
    };
    data.id = it.id || uuid();
    return sql`INSERT INTO "jobQueue" ${sql(
      data,
      "id",
      "isComplete",
      "priority",
      "scheduledAt",
      "name",
      "data",
      "createdAt",
      "updatedAt",
    )} ON CONFLICT ("id") DO UPDATE SET isComplete = EXCLUDED.isComplete, priority = EXCLUDED.priority, scheduledAt = EXCLUDED.scheduledAt, name = EXCLUDED.name, data = EXCLUDED.data, updatedAt = EXCLUDED.updatedAt RETURNING "id", "isComplete", "priority", "scheduledAt", "name", "data", "createdAt", "updatedAt"`;
  },

  /**
   * Note: Use only when name has a unique constraint
   * @param sql
   * @param { StoreJobQueueInsertPartial_Input & { id?: number } } it
   * @returns {Promise<StoreJobQueue[]>}
   */
  jobQueueUpsertByName: (sql, it) => {
    const data = {
      isComplete: it.isComplete ?? false,
      priority: it.priority ?? 0,
      scheduledAt: it.scheduledAt ?? new Date(),
      name: it.name ?? undefined,
      data: JSON.stringify(it.data ?? {}),
      createdAt: it.createdAt ?? new Date(),
      updatedAt: it.updatedAt ?? new Date(),
    };
    data.id = it.id || uuid();
    return sql`INSERT INTO "jobQueue" ${sql(
      data,
      "id",
      "isComplete",
      "priority",
      "scheduledAt",
      "name",
      "data",
      "createdAt",
      "updatedAt",
    )} ON CONFLICT ("name") DO UPDATE SET isComplete = EXCLUDED.isComplete, priority = EXCLUDED.priority, scheduledAt = EXCLUDED.scheduledAt, data = EXCLUDED.data, updatedAt = EXCLUDED.updatedAt RETURNING "id", "isComplete", "priority", "scheduledAt", "name", "data", "createdAt", "updatedAt"`;
  },
};
