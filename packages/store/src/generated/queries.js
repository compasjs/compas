// Generated by @lbu/code-gen
/* eslint-disable no-unused-vars */

import { uuid } from "@lbu/stdlib";

export const storeQueries = {
  /**
   * Queries for StoreFile
   * Docs:
   * Where docs: By default 'where.deletedAtInclude' will only include 'null' values. To use the other generated variants like 'deletedAtGreaterThan', set this value to 'true'.
   */

  /**
   * @param {Postgres} sql
   * @param { StoreFileWhere} [where]
   * @returns {Promise<StoreFile[]>}
   */
  fileSelect: (sql, where) => sql`
SELECT
f."id", f."bucketName", f."contentLength", f."contentType", f."name", f."createdAt", f."updatedAt", f."deletedAt"
FROM "file" f
WHERE (COALESCE(${where?.id ?? null}, NULL) IS NULL OR f."id" = ${
    where?.id ?? null
  }) AND (COALESCE(${
    where?.idIn ?? null
  }, NULL) IS NULL OR f."id" = ANY (${sql.array(
    where?.idIn ?? [],
  )}::uuid[])) AND (COALESCE(${
    where?.bucketName ?? null
  }, NULL) IS NULL OR f."bucketName" = ${
    where?.bucketName ?? null
  }) AND (COALESCE(${
    where?.bucketNameLike ?? null
  }, NULL) IS NULL OR f."bucketName" LIKE ${`%${where?.bucketNameLike}%`}) AND (COALESCE(${
    where?.createdAt ?? null
  }, NULL) IS NULL OR f."createdAt" = ${
    where?.createdAt ?? null
  }) AND (COALESCE(${
    where?.createdAtGreaterThan ?? null
  }, NULL) IS NULL OR f."createdAt" > ${
    where?.createdAtGreaterThan ?? null
  }) AND (COALESCE(${
    where?.createdAtLowerThan ?? null
  }, NULL) IS NULL OR f."createdAt" < ${
    where?.createdAtLowerThan ?? null
  }) AND (COALESCE(${
    where?.updatedAt ?? null
  }, NULL) IS NULL OR f."updatedAt" = ${
    where?.updatedAt ?? null
  }) AND (COALESCE(${
    where?.updatedAtGreaterThan ?? null
  }, NULL) IS NULL OR f."updatedAt" > ${
    where?.updatedAtGreaterThan ?? null
  }) AND (COALESCE(${
    where?.updatedAtLowerThan ?? null
  }, NULL) IS NULL OR f."updatedAt" < ${
    where?.updatedAtLowerThan ?? null
  }) AND (${
    where?.deletedAtInclude ?? false
  } IS TRUE OR f."deletedAt" IS NULL) AND (COALESCE(${
    where?.deletedAt ?? null
  }, NULL) IS NULL OR f."deletedAt" = ${
    where?.deletedAt ?? null
  }) AND (COALESCE(${
    where?.deletedAtGreaterThan ?? null
  }, NULL) IS NULL OR f."deletedAt" > ${
    where?.deletedAtGreaterThan ?? null
  }) AND (COALESCE(${
    where?.deletedAtLowerThan ?? null
  }, NULL) IS NULL OR f."deletedAt" < ${where?.deletedAtLowerThan ?? null})
ORDER BY f."createdAt", f."updatedAt" , f."id"
`,

  /**
   * @param {Postgres} sql
   * @param { StoreFileWhere} [where]
   * @returns {Promise<number>}
   */
  fileCount: async (sql, where) => {
    const result = await sql`
SELECT count(*) AS "genCount" FROM "file" f 
WHERE (COALESCE(${where?.id ?? null}, NULL) IS NULL OR f."id" = ${
      where?.id ?? null
    }) AND (COALESCE(${
      where?.idIn ?? null
    }, NULL) IS NULL OR f."id" = ANY (${sql.array(
      where?.idIn ?? [],
    )}::uuid[])) AND (COALESCE(${
      where?.bucketName ?? null
    }, NULL) IS NULL OR f."bucketName" = ${
      where?.bucketName ?? null
    }) AND (COALESCE(${
      where?.bucketNameLike ?? null
    }, NULL) IS NULL OR f."bucketName" LIKE ${`%${where?.bucketNameLike}%`}) AND (COALESCE(${
      where?.createdAt ?? null
    }, NULL) IS NULL OR f."createdAt" = ${
      where?.createdAt ?? null
    }) AND (COALESCE(${
      where?.createdAtGreaterThan ?? null
    }, NULL) IS NULL OR f."createdAt" > ${
      where?.createdAtGreaterThan ?? null
    }) AND (COALESCE(${
      where?.createdAtLowerThan ?? null
    }, NULL) IS NULL OR f."createdAt" < ${
      where?.createdAtLowerThan ?? null
    }) AND (COALESCE(${
      where?.updatedAt ?? null
    }, NULL) IS NULL OR f."updatedAt" = ${
      where?.updatedAt ?? null
    }) AND (COALESCE(${
      where?.updatedAtGreaterThan ?? null
    }, NULL) IS NULL OR f."updatedAt" > ${
      where?.updatedAtGreaterThan ?? null
    }) AND (COALESCE(${
      where?.updatedAtLowerThan ?? null
    }, NULL) IS NULL OR f."updatedAt" < ${
      where?.updatedAtLowerThan ?? null
    }) AND (${
      where?.deletedAtInclude ?? false
    } IS TRUE OR f."deletedAt" IS NULL) AND (COALESCE(${
      where?.deletedAt ?? null
    }, NULL) IS NULL OR f."deletedAt" = ${
      where?.deletedAt ?? null
    }) AND (COALESCE(${
      where?.deletedAtGreaterThan ?? null
    }, NULL) IS NULL OR f."deletedAt" > ${
      where?.deletedAtGreaterThan ?? null
    }) AND (COALESCE(${
      where?.deletedAtLowerThan ?? null
    }, NULL) IS NULL OR f."deletedAt" < ${where?.deletedAtLowerThan ?? null})
`;
    return parseInt(result?.[0]?.genCount ?? "0");
  },

  /**
   * @param {Postgres} sql
   * @param { StoreFileWhere} [where]
   * @returns {Promise<[]>}
   */
  fileDelete: (sql, where) => sql`
UPDATE "file" f SET "deletedAt" = NOW()
WHERE (COALESCE(${where?.id ?? null}, NULL) IS NULL OR f."id" = ${
    where?.id ?? null
  }) AND (COALESCE(${
    where?.idIn ?? null
  }, NULL) IS NULL OR f."id" = ANY (${sql.array(
    where?.idIn ?? [],
  )}::uuid[])) AND (COALESCE(${
    where?.bucketName ?? null
  }, NULL) IS NULL OR f."bucketName" = ${
    where?.bucketName ?? null
  }) AND (COALESCE(${
    where?.bucketNameLike ?? null
  }, NULL) IS NULL OR f."bucketName" LIKE ${`%${where?.bucketNameLike}%`}) AND (COALESCE(${
    where?.createdAt ?? null
  }, NULL) IS NULL OR f."createdAt" = ${
    where?.createdAt ?? null
  }) AND (COALESCE(${
    where?.createdAtGreaterThan ?? null
  }, NULL) IS NULL OR f."createdAt" > ${
    where?.createdAtGreaterThan ?? null
  }) AND (COALESCE(${
    where?.createdAtLowerThan ?? null
  }, NULL) IS NULL OR f."createdAt" < ${
    where?.createdAtLowerThan ?? null
  }) AND (COALESCE(${
    where?.updatedAt ?? null
  }, NULL) IS NULL OR f."updatedAt" = ${
    where?.updatedAt ?? null
  }) AND (COALESCE(${
    where?.updatedAtGreaterThan ?? null
  }, NULL) IS NULL OR f."updatedAt" > ${
    where?.updatedAtGreaterThan ?? null
  }) AND (COALESCE(${
    where?.updatedAtLowerThan ?? null
  }, NULL) IS NULL OR f."updatedAt" < ${
    where?.updatedAtLowerThan ?? null
  }) AND (${
    where?.deletedAtInclude ?? false
  } IS TRUE OR f."deletedAt" IS NULL) AND (COALESCE(${
    where?.deletedAt ?? null
  }, NULL) IS NULL OR f."deletedAt" = ${
    where?.deletedAt ?? null
  }) AND (COALESCE(${
    where?.deletedAtGreaterThan ?? null
  }, NULL) IS NULL OR f."deletedAt" > ${
    where?.deletedAtGreaterThan ?? null
  }) AND (COALESCE(${
    where?.deletedAtLowerThan ?? null
  }, NULL) IS NULL OR f."deletedAt" < ${where?.deletedAtLowerThan ?? null})
`,

  /**
   * @param {Postgres} sql
   * @param { StoreFileWhere} [where]
   * @returns {Promise<[]>}
   */
  fileDeletePermanent: (sql, where) => sql`
DELETE FROM "file" f
WHERE (COALESCE(${where?.id ?? null}, NULL) IS NULL OR f."id" = ${
    where?.id ?? null
  }) AND (COALESCE(${
    where?.idIn ?? null
  }, NULL) IS NULL OR f."id" = ANY (${sql.array(
    where?.idIn ?? [],
  )}::uuid[])) AND (COALESCE(${
    where?.bucketName ?? null
  }, NULL) IS NULL OR f."bucketName" = ${
    where?.bucketName ?? null
  }) AND (COALESCE(${
    where?.bucketNameLike ?? null
  }, NULL) IS NULL OR f."bucketName" LIKE ${`%${where?.bucketNameLike}%`}) AND (COALESCE(${
    where?.createdAt ?? null
  }, NULL) IS NULL OR f."createdAt" = ${
    where?.createdAt ?? null
  }) AND (COALESCE(${
    where?.createdAtGreaterThan ?? null
  }, NULL) IS NULL OR f."createdAt" > ${
    where?.createdAtGreaterThan ?? null
  }) AND (COALESCE(${
    where?.createdAtLowerThan ?? null
  }, NULL) IS NULL OR f."createdAt" < ${
    where?.createdAtLowerThan ?? null
  }) AND (COALESCE(${
    where?.updatedAt ?? null
  }, NULL) IS NULL OR f."updatedAt" = ${
    where?.updatedAt ?? null
  }) AND (COALESCE(${
    where?.updatedAtGreaterThan ?? null
  }, NULL) IS NULL OR f."updatedAt" > ${
    where?.updatedAtGreaterThan ?? null
  }) AND (COALESCE(${
    where?.updatedAtLowerThan ?? null
  }, NULL) IS NULL OR f."updatedAt" < ${
    where?.updatedAtLowerThan ?? null
  }) AND (COALESCE(${
    where?.deletedAt ?? null
  }, NULL) IS NULL OR f."deletedAt" = ${
    where?.deletedAt ?? null
  }) AND (COALESCE(${
    where?.deletedAtGreaterThan ?? null
  }, NULL) IS NULL OR f."deletedAt" > ${
    where?.deletedAtGreaterThan ?? null
  }) AND (COALESCE(${
    where?.deletedAtLowerThan ?? null
  }, NULL) IS NULL OR f."deletedAt" < ${where?.deletedAtLowerThan ?? null})
`,

  /**
   * @param {Postgres} sql
   * @param { StoreFileInsertPartial_Input|StoreFileInsertPartial_Input[]} insert
   * @returns {Promise<StoreFile[]>}
   */
  fileInsert: (sql, insert) => {
    const data = Array.isArray(insert) ? insert : [insert];
    if (data.length === 0) {
      return [];
    }
    let query = `INSERT INTO "file" ("bucketName", "contentLength", "contentType", "name", "createdAt", "updatedAt", "deletedAt") VALUES `;
    const argList = [];
    let idx = 1;
    for (const it of data) {
      argList.push(
        it.bucketName ?? null,
        it.contentLength ?? null,
        it.contentType ?? null,
        it.name ?? null,
        it.createdAt ?? new Date(),
        it.updatedAt ?? new Date(),
        it.deletedAt ?? null,
      );
      query += `($${idx++}, $${idx++}, $${idx++}, $${idx++}, $${idx++}, $${idx++}, $${idx++}),`;
    }
    // Remove trailing comma
    query = query.substring(0, query.length - 1);
    query += ` RETURNING "id", "bucketName", "contentLength", "contentType", "name", "createdAt", "updatedAt", "deletedAt"`;
    return sql.unsafe(query, argList);
  },

  /**
   * @param {Postgres} sql
   * @param { StoreFileInsertPartial_Input} value
   * @param { StoreFileWhere} [where]
   * @returns {Promise<StoreFile[]>}
   */
  fileUpdate: (sql, value, where) => {
    let query = `UPDATE "file" f SET `;
    const argList = [];
    let idx = 1;
    if (value["bucketName"] !== undefined) {
      query += `"bucketName" = $${idx++}, `;
      argList.push(value["bucketName"]);
    }
    if (value["contentLength"] !== undefined) {
      query += `"contentLength" = $${idx++}, `;
      argList.push(value["contentLength"]);
    }
    if (value["contentType"] !== undefined) {
      query += `"contentType" = $${idx++}, `;
      argList.push(value["contentType"]);
    }
    if (value["name"] !== undefined) {
      query += `"name" = $${idx++}, `;
      argList.push(value["name"]);
    }
    if (value["createdAt"] !== undefined) {
      query += `"createdAt" = $${idx++}, `;
      argList.push(value["createdAt"]);
    }
    if (value["deletedAt"] !== undefined) {
      query += `"deletedAt" = $${idx++}, `;
      argList.push(value["deletedAt"]);
    }
    query += `"updatedAt" = $${idx++}, `;
    argList.push(new Date());
    query = query.substring(0, query.length - 2);
    query += ` WHERE `;
    if (where.id !== undefined) {
      query += `f."id" `;
      query += `= $${idx++}`;
      argList.push(where.id);
      query += " AND ";
    }
    if (where.idIn !== undefined) {
      query += `f."id" `;
      query += `= ANY (ARRAY[`;
      let addOne = false;
      for (const value of where.idIn || []) {
        addOne = true;
        query += `$${idx++},`;
        argList.push(value);
      }
      query = `${query.substring(
        0,
        query.length - (addOne ? 1 : 0),
      )}]::uuid[])`;
      query += " AND ";
    }
    if (where.bucketName !== undefined) {
      query += `f."bucketName" `;
      query += `= $${idx++}`;
      argList.push(where.bucketName);
      query += " AND ";
    }
    if (where.bucketNameLike !== undefined) {
      query += `f."bucketName" `;
      query += `LIKE $${idx++}`;
      argList.push(`%${where.bucketNameLike}%`);
      query += " AND ";
    }
    if (where.createdAt !== undefined) {
      query += `f."createdAt" `;
      query += `= $${idx++}`;
      argList.push(where.createdAt);
      query += " AND ";
    }
    if (where.createdAtGreaterThan !== undefined) {
      query += `f."createdAt" `;
      query += `> $${idx++}`;
      argList.push(where.createdAtGreaterThan);
      query += " AND ";
    }
    if (where.createdAtLowerThan !== undefined) {
      query += `f."createdAt" `;
      query += `< $${idx++}`;
      argList.push(where.createdAtLowerThan);
      query += " AND ";
    }
    if (where.updatedAt !== undefined) {
      query += `f."updatedAt" `;
      query += `= $${idx++}`;
      argList.push(where.updatedAt);
      query += " AND ";
    }
    if (where.updatedAtGreaterThan !== undefined) {
      query += `f."updatedAt" `;
      query += `> $${idx++}`;
      argList.push(where.updatedAtGreaterThan);
      query += " AND ";
    }
    if (where.updatedAtLowerThan !== undefined) {
      query += `f."updatedAt" `;
      query += `< $${idx++}`;
      argList.push(where.updatedAtLowerThan);
      query += " AND ";
    }
    if (where.deletedAtInclude !== undefined) {
      if (where.deletedAtInclude ?? false === false) {
        query += `f."deletedAt" IS NULL`;
      }
    }
    if (where.deletedAt !== undefined) {
      query += `f."deletedAt" `;
      query += `= $${idx++}`;
      argList.push(where.deletedAt);
      query += " AND ";
    }
    if (where.deletedAtGreaterThan !== undefined) {
      query += `f."deletedAt" `;
      query += `> $${idx++}`;
      argList.push(where.deletedAtGreaterThan);
      query += " AND ";
    }
    if (where.deletedAtLowerThan !== undefined) {
      query += `f."deletedAt" `;
      query += `< $${idx++}`;
      argList.push(where.deletedAtLowerThan);
      query += " AND ";
    }
    query = query.substring(0, query.length - 4);
    query += ` RETURNING f."id", f."bucketName", f."contentLength", f."contentType", f."name", f."createdAt", f."updatedAt", f."deletedAt"`;
    return sql.unsafe(query, argList);
  },

  /**
   * Note: Use only when id has a unique constraint
   * @param {Postgres} sql
   * @param { StoreFileInsertPartial_Input & { id?: string } } it
   * @returns {Promise<StoreFile[]>}
   */
  fileUpsert: (sql, it) => {
    return sql`
INSERT INTO "file" ("id", "bucketName", "contentLength", "contentType", "name", "createdAt", "updatedAt", "deletedAt"
) VALUES (
${it.id ?? uuid()}, ${it.bucketName ?? null}, ${it.contentLength ?? null}, ${
      it.contentType ?? null
    }, ${it.name ?? null}, ${it.createdAt ?? new Date()}, ${
      it.updatedAt ?? new Date()
    }, ${it.deletedAt ?? null}
) ON CONFLICT("id") DO UPDATE SET
"bucketName" = EXCLUDED."bucketName", "contentLength" = EXCLUDED."contentLength", "contentType" = EXCLUDED."contentType", "name" = EXCLUDED."name", "updatedAt" = EXCLUDED."updatedAt", "deletedAt" = EXCLUDED."deletedAt"
RETURNING "id", "bucketName", "contentLength", "contentType", "name", "createdAt", "updatedAt", "deletedAt"
`;
  },

  /**
   * Note: Use only when bucketName has a unique constraint
   * @param {Postgres} sql
   * @param { StoreFileInsertPartial_Input & { id?: string } } it
   * @returns {Promise<StoreFile[]>}
   */
  fileUpsertByBucketName: (sql, it) => {
    return sql`
INSERT INTO "file" ("id", "bucketName", "contentLength", "contentType", "name", "createdAt", "updatedAt", "deletedAt"
) VALUES (
${it.id ?? uuid()}, ${it.bucketName ?? null}, ${it.contentLength ?? null}, ${
      it.contentType ?? null
    }, ${it.name ?? null}, ${it.createdAt ?? new Date()}, ${
      it.updatedAt ?? new Date()
    }, ${it.deletedAt ?? null}
) ON CONFLICT("bucketName") DO UPDATE SET
"contentLength" = EXCLUDED."contentLength", "contentType" = EXCLUDED."contentType", "name" = EXCLUDED."name", "updatedAt" = EXCLUDED."updatedAt", "deletedAt" = EXCLUDED."deletedAt"
RETURNING "id", "bucketName", "contentLength", "contentType", "name", "createdAt", "updatedAt", "deletedAt"
`;
  },

  /**
   * Note: Use only when createdAt has a unique constraint
   * @param {Postgres} sql
   * @param { StoreFileInsertPartial_Input & { id?: string } } it
   * @returns {Promise<StoreFile[]>}
   */
  fileUpsertByCreatedAt: (sql, it) => {
    return sql`
INSERT INTO "file" ("id", "bucketName", "contentLength", "contentType", "name", "createdAt", "updatedAt", "deletedAt"
) VALUES (
${it.id ?? uuid()}, ${it.bucketName ?? null}, ${it.contentLength ?? null}, ${
      it.contentType ?? null
    }, ${it.name ?? null}, ${it.createdAt ?? new Date()}, ${
      it.updatedAt ?? new Date()
    }, ${it.deletedAt ?? null}
) ON CONFLICT("createdAt") DO UPDATE SET
"bucketName" = EXCLUDED."bucketName", "contentLength" = EXCLUDED."contentLength", "contentType" = EXCLUDED."contentType", "name" = EXCLUDED."name", "updatedAt" = EXCLUDED."updatedAt", "deletedAt" = EXCLUDED."deletedAt"
RETURNING "id", "bucketName", "contentLength", "contentType", "name", "createdAt", "updatedAt", "deletedAt"
`;
  },

  /**
   * Note: Use only when updatedAt has a unique constraint
   * @param {Postgres} sql
   * @param { StoreFileInsertPartial_Input & { id?: string } } it
   * @returns {Promise<StoreFile[]>}
   */
  fileUpsertByUpdatedAt: (sql, it) => {
    return sql`
INSERT INTO "file" ("id", "bucketName", "contentLength", "contentType", "name", "createdAt", "updatedAt", "deletedAt"
) VALUES (
${it.id ?? uuid()}, ${it.bucketName ?? null}, ${it.contentLength ?? null}, ${
      it.contentType ?? null
    }, ${it.name ?? null}, ${it.createdAt ?? new Date()}, ${
      it.updatedAt ?? new Date()
    }, ${it.deletedAt ?? null}
) ON CONFLICT("updatedAt") DO UPDATE SET
"bucketName" = EXCLUDED."bucketName", "contentLength" = EXCLUDED."contentLength", "contentType" = EXCLUDED."contentType", "name" = EXCLUDED."name", "deletedAt" = EXCLUDED."deletedAt"
RETURNING "id", "bucketName", "contentLength", "contentType", "name", "createdAt", "updatedAt", "deletedAt"
`;
  },

  /**
   * Note: Use only when deletedAt has a unique constraint
   * @param {Postgres} sql
   * @param { StoreFileInsertPartial_Input & { id?: string } } it
   * @returns {Promise<StoreFile[]>}
   */
  fileUpsertByDeletedAt: (sql, it) => {
    return sql`
INSERT INTO "file" ("id", "bucketName", "contentLength", "contentType", "name", "createdAt", "updatedAt", "deletedAt"
) VALUES (
${it.id ?? uuid()}, ${it.bucketName ?? null}, ${it.contentLength ?? null}, ${
      it.contentType ?? null
    }, ${it.name ?? null}, ${it.createdAt ?? new Date()}, ${
      it.updatedAt ?? new Date()
    }, ${it.deletedAt ?? null}
) ON CONFLICT("deletedAt") DO UPDATE SET
"bucketName" = EXCLUDED."bucketName", "contentLength" = EXCLUDED."contentLength", "contentType" = EXCLUDED."contentType", "name" = EXCLUDED."name", "updatedAt" = EXCLUDED."updatedAt"
RETURNING "id", "bucketName", "contentLength", "contentType", "name", "createdAt", "updatedAt", "deletedAt"
`;
  },

  /**
   * @param {Postgres} sql
   * @param { StoreJobWhere} [where]
   * @returns {Promise<StoreJob[]>}
   */
  jobSelect: (sql, where) => sql`
SELECT
j."id", j."isComplete", j."priority", j."scheduledAt", j."name", j."data", j."createdAt", j."updatedAt"
FROM "job" j
WHERE (COALESCE(${where?.id ?? null}, NULL) IS NULL OR j."id" = ${
    where?.id ?? null
  }) AND (COALESCE(${where?.idGreaterThan ?? null}, NULL) IS NULL OR j."id" > ${
    where?.idGreaterThan ?? null
  }) AND (COALESCE(${where?.idLowerThan ?? null}, NULL) IS NULL OR j."id" < ${
    where?.idLowerThan ?? null
  }) AND (COALESCE(${
    where?.scheduledAt ?? null
  }, NULL) IS NULL OR j."scheduledAt" = ${
    where?.scheduledAt ?? null
  }) AND (COALESCE(${
    where?.scheduledAtGreaterThan ?? null
  }, NULL) IS NULL OR j."scheduledAt" > ${
    where?.scheduledAtGreaterThan ?? null
  }) AND (COALESCE(${
    where?.scheduledAtLowerThan ?? null
  }, NULL) IS NULL OR j."scheduledAt" < ${
    where?.scheduledAtLowerThan ?? null
  }) AND (COALESCE(${where?.name ?? null}, NULL) IS NULL OR j."name" = ${
    where?.name ?? null
  }) AND (COALESCE(${
    where?.nameLike ?? null
  }, NULL) IS NULL OR j."name" LIKE ${`%${where?.nameLike}%`}) AND (COALESCE(${
    where?.createdAt ?? null
  }, NULL) IS NULL OR j."createdAt" = ${
    where?.createdAt ?? null
  }) AND (COALESCE(${
    where?.createdAtGreaterThan ?? null
  }, NULL) IS NULL OR j."createdAt" > ${
    where?.createdAtGreaterThan ?? null
  }) AND (COALESCE(${
    where?.createdAtLowerThan ?? null
  }, NULL) IS NULL OR j."createdAt" < ${
    where?.createdAtLowerThan ?? null
  }) AND (COALESCE(${
    where?.updatedAt ?? null
  }, NULL) IS NULL OR j."updatedAt" = ${
    where?.updatedAt ?? null
  }) AND (COALESCE(${
    where?.updatedAtGreaterThan ?? null
  }, NULL) IS NULL OR j."updatedAt" > ${
    where?.updatedAtGreaterThan ?? null
  }) AND (COALESCE(${
    where?.updatedAtLowerThan ?? null
  }, NULL) IS NULL OR j."updatedAt" < ${where?.updatedAtLowerThan ?? null})
ORDER BY j."createdAt", j."updatedAt" , j."id"
`,

  /**
   * @param {Postgres} sql
   * @param { StoreJobWhere} [where]
   * @returns {Promise<number>}
   */
  jobCount: async (sql, where) => {
    const result = await sql`
SELECT count(*) AS "genCount" FROM "job" j 
WHERE (COALESCE(${where?.id ?? null}, NULL) IS NULL OR j."id" = ${
      where?.id ?? null
    }) AND (COALESCE(${
      where?.idGreaterThan ?? null
    }, NULL) IS NULL OR j."id" > ${
      where?.idGreaterThan ?? null
    }) AND (COALESCE(${where?.idLowerThan ?? null}, NULL) IS NULL OR j."id" < ${
      where?.idLowerThan ?? null
    }) AND (COALESCE(${
      where?.scheduledAt ?? null
    }, NULL) IS NULL OR j."scheduledAt" = ${
      where?.scheduledAt ?? null
    }) AND (COALESCE(${
      where?.scheduledAtGreaterThan ?? null
    }, NULL) IS NULL OR j."scheduledAt" > ${
      where?.scheduledAtGreaterThan ?? null
    }) AND (COALESCE(${
      where?.scheduledAtLowerThan ?? null
    }, NULL) IS NULL OR j."scheduledAt" < ${
      where?.scheduledAtLowerThan ?? null
    }) AND (COALESCE(${where?.name ?? null}, NULL) IS NULL OR j."name" = ${
      where?.name ?? null
    }) AND (COALESCE(${
      where?.nameLike ?? null
    }, NULL) IS NULL OR j."name" LIKE ${`%${where?.nameLike}%`}) AND (COALESCE(${
      where?.createdAt ?? null
    }, NULL) IS NULL OR j."createdAt" = ${
      where?.createdAt ?? null
    }) AND (COALESCE(${
      where?.createdAtGreaterThan ?? null
    }, NULL) IS NULL OR j."createdAt" > ${
      where?.createdAtGreaterThan ?? null
    }) AND (COALESCE(${
      where?.createdAtLowerThan ?? null
    }, NULL) IS NULL OR j."createdAt" < ${
      where?.createdAtLowerThan ?? null
    }) AND (COALESCE(${
      where?.updatedAt ?? null
    }, NULL) IS NULL OR j."updatedAt" = ${
      where?.updatedAt ?? null
    }) AND (COALESCE(${
      where?.updatedAtGreaterThan ?? null
    }, NULL) IS NULL OR j."updatedAt" > ${
      where?.updatedAtGreaterThan ?? null
    }) AND (COALESCE(${
      where?.updatedAtLowerThan ?? null
    }, NULL) IS NULL OR j."updatedAt" < ${where?.updatedAtLowerThan ?? null})
`;
    return parseInt(result?.[0]?.genCount ?? "0");
  },

  /**
   * @param {Postgres} sql
   * @param { StoreJobWhere} [where]
   * @returns {Promise<[]>}
   */
  jobDelete: (sql, where) => sql`
DELETE FROM "job" j
WHERE (COALESCE(${where?.id ?? null}, NULL) IS NULL OR j."id" = ${
    where?.id ?? null
  }) AND (COALESCE(${where?.idGreaterThan ?? null}, NULL) IS NULL OR j."id" > ${
    where?.idGreaterThan ?? null
  }) AND (COALESCE(${where?.idLowerThan ?? null}, NULL) IS NULL OR j."id" < ${
    where?.idLowerThan ?? null
  }) AND (COALESCE(${
    where?.scheduledAt ?? null
  }, NULL) IS NULL OR j."scheduledAt" = ${
    where?.scheduledAt ?? null
  }) AND (COALESCE(${
    where?.scheduledAtGreaterThan ?? null
  }, NULL) IS NULL OR j."scheduledAt" > ${
    where?.scheduledAtGreaterThan ?? null
  }) AND (COALESCE(${
    where?.scheduledAtLowerThan ?? null
  }, NULL) IS NULL OR j."scheduledAt" < ${
    where?.scheduledAtLowerThan ?? null
  }) AND (COALESCE(${where?.name ?? null}, NULL) IS NULL OR j."name" = ${
    where?.name ?? null
  }) AND (COALESCE(${
    where?.nameLike ?? null
  }, NULL) IS NULL OR j."name" LIKE ${`%${where?.nameLike}%`}) AND (COALESCE(${
    where?.createdAt ?? null
  }, NULL) IS NULL OR j."createdAt" = ${
    where?.createdAt ?? null
  }) AND (COALESCE(${
    where?.createdAtGreaterThan ?? null
  }, NULL) IS NULL OR j."createdAt" > ${
    where?.createdAtGreaterThan ?? null
  }) AND (COALESCE(${
    where?.createdAtLowerThan ?? null
  }, NULL) IS NULL OR j."createdAt" < ${
    where?.createdAtLowerThan ?? null
  }) AND (COALESCE(${
    where?.updatedAt ?? null
  }, NULL) IS NULL OR j."updatedAt" = ${
    where?.updatedAt ?? null
  }) AND (COALESCE(${
    where?.updatedAtGreaterThan ?? null
  }, NULL) IS NULL OR j."updatedAt" > ${
    where?.updatedAtGreaterThan ?? null
  }) AND (COALESCE(${
    where?.updatedAtLowerThan ?? null
  }, NULL) IS NULL OR j."updatedAt" < ${where?.updatedAtLowerThan ?? null})
`,

  /**
   * @param {Postgres} sql
   * @param { StoreJobInsertPartial_Input|StoreJobInsertPartial_Input[]} insert
   * @returns {Promise<StoreJob[]>}
   */
  jobInsert: (sql, insert) => {
    const data = Array.isArray(insert) ? insert : [insert];
    if (data.length === 0) {
      return [];
    }
    let query = `INSERT INTO "job" ("isComplete", "priority", "scheduledAt", "name", "data", "createdAt", "updatedAt") VALUES `;
    const argList = [];
    let idx = 1;
    for (const it of data) {
      argList.push(
        it.isComplete ?? false,
        it.priority ?? 0,
        it.scheduledAt ?? new Date(),
        it.name ?? null,
        JSON.stringify(it.data ?? {}),
        it.createdAt ?? new Date(),
        it.updatedAt ?? new Date(),
      );
      query += `($${idx++}, $${idx++}, $${idx++}, $${idx++}, $${idx++}, $${idx++}, $${idx++}),`;
    }
    // Remove trailing comma
    query = query.substring(0, query.length - 1);
    query += ` RETURNING "id", "isComplete", "priority", "scheduledAt", "name", "data", "createdAt", "updatedAt"`;
    return sql.unsafe(query, argList);
  },

  /**
   * @param {Postgres} sql
   * @param { StoreJobInsertPartial_Input} value
   * @param { StoreJobWhere} [where]
   * @returns {Promise<StoreJob[]>}
   */
  jobUpdate: (sql, value, where) => {
    let query = `UPDATE "job" j SET `;
    const argList = [];
    let idx = 1;
    if (value["isComplete"] !== undefined) {
      query += `"isComplete" = $${idx++}, `;
      argList.push(value["isComplete"]);
    }
    if (value["priority"] !== undefined) {
      query += `"priority" = $${idx++}, `;
      argList.push(value["priority"]);
    }
    if (value["scheduledAt"] !== undefined) {
      query += `"scheduledAt" = $${idx++}, `;
      argList.push(value["scheduledAt"]);
    }
    if (value["name"] !== undefined) {
      query += `"name" = $${idx++}, `;
      argList.push(value["name"]);
    }
    if (value["data"] !== undefined) {
      query += `"data" = $${idx++}, `;
      argList.push(JSON.stringify(value["data"]));
    }
    if (value["createdAt"] !== undefined) {
      query += `"createdAt" = $${idx++}, `;
      argList.push(value["createdAt"]);
    }
    query += `"updatedAt" = $${idx++}, `;
    argList.push(new Date());
    query = query.substring(0, query.length - 2);
    query += ` WHERE `;
    if (where.id !== undefined) {
      query += `j."id" `;
      query += `= $${idx++}`;
      argList.push(where.id);
      query += " AND ";
    }
    if (where.idGreaterThan !== undefined) {
      query += `j."id" `;
      query += `> $${idx++}`;
      argList.push(where.idGreaterThan);
      query += " AND ";
    }
    if (where.idLowerThan !== undefined) {
      query += `j."id" `;
      query += `< $${idx++}`;
      argList.push(where.idLowerThan);
      query += " AND ";
    }
    if (where.scheduledAt !== undefined) {
      query += `j."scheduledAt" `;
      query += `= $${idx++}`;
      argList.push(where.scheduledAt);
      query += " AND ";
    }
    if (where.scheduledAtGreaterThan !== undefined) {
      query += `j."scheduledAt" `;
      query += `> $${idx++}`;
      argList.push(where.scheduledAtGreaterThan);
      query += " AND ";
    }
    if (where.scheduledAtLowerThan !== undefined) {
      query += `j."scheduledAt" `;
      query += `< $${idx++}`;
      argList.push(where.scheduledAtLowerThan);
      query += " AND ";
    }
    if (where.name !== undefined) {
      query += `j."name" `;
      query += `= $${idx++}`;
      argList.push(where.name);
      query += " AND ";
    }
    if (where.nameLike !== undefined) {
      query += `j."name" `;
      query += `LIKE $${idx++}`;
      argList.push(`%${where.nameLike}%`);
      query += " AND ";
    }
    if (where.createdAt !== undefined) {
      query += `j."createdAt" `;
      query += `= $${idx++}`;
      argList.push(where.createdAt);
      query += " AND ";
    }
    if (where.createdAtGreaterThan !== undefined) {
      query += `j."createdAt" `;
      query += `> $${idx++}`;
      argList.push(where.createdAtGreaterThan);
      query += " AND ";
    }
    if (where.createdAtLowerThan !== undefined) {
      query += `j."createdAt" `;
      query += `< $${idx++}`;
      argList.push(where.createdAtLowerThan);
      query += " AND ";
    }
    if (where.updatedAt !== undefined) {
      query += `j."updatedAt" `;
      query += `= $${idx++}`;
      argList.push(where.updatedAt);
      query += " AND ";
    }
    if (where.updatedAtGreaterThan !== undefined) {
      query += `j."updatedAt" `;
      query += `> $${idx++}`;
      argList.push(where.updatedAtGreaterThan);
      query += " AND ";
    }
    if (where.updatedAtLowerThan !== undefined) {
      query += `j."updatedAt" `;
      query += `< $${idx++}`;
      argList.push(where.updatedAtLowerThan);
      query += " AND ";
    }
    query = query.substring(0, query.length - 4);
    query += ` RETURNING j."id", j."isComplete", j."priority", j."scheduledAt", j."name", j."data", j."createdAt", j."updatedAt"`;
    return sql.unsafe(query, argList);
  },

  /**
   * Note: Use only when id has a unique constraint
   * @param {Postgres} sql
   * @param { StoreJobInsertPartial_Input & { id?: number } } it
   * @returns {Promise<StoreJob[]>}
   */
  jobUpsert: (sql, it) => {
    return sql`
INSERT INTO "job" ("id", "isComplete", "priority", "scheduledAt", "name", "data", "createdAt", "updatedAt"
) VALUES (
${it.id ?? uuid()}, ${it.isComplete ?? false}, ${it.priority ?? 0}, ${
      it.scheduledAt ?? new Date()
    }, ${it.name ?? null}, ${JSON.stringify(it.data ?? {})}, ${
      it.createdAt ?? new Date()
    }, ${it.updatedAt ?? new Date()}
) ON CONFLICT("id") DO UPDATE SET
"isComplete" = EXCLUDED."isComplete", "priority" = EXCLUDED."priority", "scheduledAt" = EXCLUDED."scheduledAt", "name" = EXCLUDED."name", "data" = EXCLUDED."data", "updatedAt" = EXCLUDED."updatedAt"
RETURNING "id", "isComplete", "priority", "scheduledAt", "name", "data", "createdAt", "updatedAt"
`;
  },

  /**
   * Note: Use only when scheduledAt has a unique constraint
   * @param {Postgres} sql
   * @param { StoreJobInsertPartial_Input & { id?: number } } it
   * @returns {Promise<StoreJob[]>}
   */
  jobUpsertByScheduledAt: (sql, it) => {
    return sql`
INSERT INTO "job" ("id", "isComplete", "priority", "scheduledAt", "name", "data", "createdAt", "updatedAt"
) VALUES (
${it.id ?? uuid()}, ${it.isComplete ?? false}, ${it.priority ?? 0}, ${
      it.scheduledAt ?? new Date()
    }, ${it.name ?? null}, ${JSON.stringify(it.data ?? {})}, ${
      it.createdAt ?? new Date()
    }, ${it.updatedAt ?? new Date()}
) ON CONFLICT("scheduledAt") DO UPDATE SET
"isComplete" = EXCLUDED."isComplete", "priority" = EXCLUDED."priority", "name" = EXCLUDED."name", "data" = EXCLUDED."data", "updatedAt" = EXCLUDED."updatedAt"
RETURNING "id", "isComplete", "priority", "scheduledAt", "name", "data", "createdAt", "updatedAt"
`;
  },

  /**
   * Note: Use only when name has a unique constraint
   * @param {Postgres} sql
   * @param { StoreJobInsertPartial_Input & { id?: number } } it
   * @returns {Promise<StoreJob[]>}
   */
  jobUpsertByName: (sql, it) => {
    return sql`
INSERT INTO "job" ("id", "isComplete", "priority", "scheduledAt", "name", "data", "createdAt", "updatedAt"
) VALUES (
${it.id ?? uuid()}, ${it.isComplete ?? false}, ${it.priority ?? 0}, ${
      it.scheduledAt ?? new Date()
    }, ${it.name ?? null}, ${JSON.stringify(it.data ?? {})}, ${
      it.createdAt ?? new Date()
    }, ${it.updatedAt ?? new Date()}
) ON CONFLICT("name") DO UPDATE SET
"isComplete" = EXCLUDED."isComplete", "priority" = EXCLUDED."priority", "scheduledAt" = EXCLUDED."scheduledAt", "data" = EXCLUDED."data", "updatedAt" = EXCLUDED."updatedAt"
RETURNING "id", "isComplete", "priority", "scheduledAt", "name", "data", "createdAt", "updatedAt"
`;
  },

  /**
   * Note: Use only when createdAt has a unique constraint
   * @param {Postgres} sql
   * @param { StoreJobInsertPartial_Input & { id?: number } } it
   * @returns {Promise<StoreJob[]>}
   */
  jobUpsertByCreatedAt: (sql, it) => {
    return sql`
INSERT INTO "job" ("id", "isComplete", "priority", "scheduledAt", "name", "data", "createdAt", "updatedAt"
) VALUES (
${it.id ?? uuid()}, ${it.isComplete ?? false}, ${it.priority ?? 0}, ${
      it.scheduledAt ?? new Date()
    }, ${it.name ?? null}, ${JSON.stringify(it.data ?? {})}, ${
      it.createdAt ?? new Date()
    }, ${it.updatedAt ?? new Date()}
) ON CONFLICT("createdAt") DO UPDATE SET
"isComplete" = EXCLUDED."isComplete", "priority" = EXCLUDED."priority", "scheduledAt" = EXCLUDED."scheduledAt", "name" = EXCLUDED."name", "data" = EXCLUDED."data", "updatedAt" = EXCLUDED."updatedAt"
RETURNING "id", "isComplete", "priority", "scheduledAt", "name", "data", "createdAt", "updatedAt"
`;
  },

  /**
   * Note: Use only when updatedAt has a unique constraint
   * @param {Postgres} sql
   * @param { StoreJobInsertPartial_Input & { id?: number } } it
   * @returns {Promise<StoreJob[]>}
   */
  jobUpsertByUpdatedAt: (sql, it) => {
    return sql`
INSERT INTO "job" ("id", "isComplete", "priority", "scheduledAt", "name", "data", "createdAt", "updatedAt"
) VALUES (
${it.id ?? uuid()}, ${it.isComplete ?? false}, ${it.priority ?? 0}, ${
      it.scheduledAt ?? new Date()
    }, ${it.name ?? null}, ${JSON.stringify(it.data ?? {})}, ${
      it.createdAt ?? new Date()
    }, ${it.updatedAt ?? new Date()}
) ON CONFLICT("updatedAt") DO UPDATE SET
"isComplete" = EXCLUDED."isComplete", "priority" = EXCLUDED."priority", "scheduledAt" = EXCLUDED."scheduledAt", "name" = EXCLUDED."name", "data" = EXCLUDED."data"
RETURNING "id", "isComplete", "priority", "scheduledAt", "name", "data", "createdAt", "updatedAt"
`;
  },

  /**
   * @param {Postgres} sql
   * @param { StoreSessionWhere} [where]
   * @returns {Promise<StoreSession[]>}
   */
  sessionSelect: (sql, where) => sql`
SELECT
s."id", s."expires", s."data", s."createdAt", s."updatedAt"
FROM "session" s
WHERE (COALESCE(${where?.id ?? null}, NULL) IS NULL OR s."id" = ${
    where?.id ?? null
  }) AND (COALESCE(${
    where?.idIn ?? null
  }, NULL) IS NULL OR s."id" = ANY (${sql.array(
    where?.idIn ?? [],
  )}::uuid[])) AND (COALESCE(${
    where?.expires ?? null
  }, NULL) IS NULL OR s."expires" = ${where?.expires ?? null}) AND (COALESCE(${
    where?.expiresGreaterThan ?? null
  }, NULL) IS NULL OR s."expires" > ${
    where?.expiresGreaterThan ?? null
  }) AND (COALESCE(${
    where?.expiresLowerThan ?? null
  }, NULL) IS NULL OR s."expires" < ${
    where?.expiresLowerThan ?? null
  }) AND (COALESCE(${
    where?.createdAt ?? null
  }, NULL) IS NULL OR s."createdAt" = ${
    where?.createdAt ?? null
  }) AND (COALESCE(${
    where?.createdAtGreaterThan ?? null
  }, NULL) IS NULL OR s."createdAt" > ${
    where?.createdAtGreaterThan ?? null
  }) AND (COALESCE(${
    where?.createdAtLowerThan ?? null
  }, NULL) IS NULL OR s."createdAt" < ${
    where?.createdAtLowerThan ?? null
  }) AND (COALESCE(${
    where?.updatedAt ?? null
  }, NULL) IS NULL OR s."updatedAt" = ${
    where?.updatedAt ?? null
  }) AND (COALESCE(${
    where?.updatedAtGreaterThan ?? null
  }, NULL) IS NULL OR s."updatedAt" > ${
    where?.updatedAtGreaterThan ?? null
  }) AND (COALESCE(${
    where?.updatedAtLowerThan ?? null
  }, NULL) IS NULL OR s."updatedAt" < ${where?.updatedAtLowerThan ?? null})
ORDER BY s."createdAt", s."updatedAt" , s."id"
`,

  /**
   * @param {Postgres} sql
   * @param { StoreSessionWhere} [where]
   * @returns {Promise<number>}
   */
  sessionCount: async (sql, where) => {
    const result = await sql`
SELECT count(*) AS "genCount" FROM "session" s 
WHERE (COALESCE(${where?.id ?? null}, NULL) IS NULL OR s."id" = ${
      where?.id ?? null
    }) AND (COALESCE(${
      where?.idIn ?? null
    }, NULL) IS NULL OR s."id" = ANY (${sql.array(
      where?.idIn ?? [],
    )}::uuid[])) AND (COALESCE(${
      where?.expires ?? null
    }, NULL) IS NULL OR s."expires" = ${
      where?.expires ?? null
    }) AND (COALESCE(${
      where?.expiresGreaterThan ?? null
    }, NULL) IS NULL OR s."expires" > ${
      where?.expiresGreaterThan ?? null
    }) AND (COALESCE(${
      where?.expiresLowerThan ?? null
    }, NULL) IS NULL OR s."expires" < ${
      where?.expiresLowerThan ?? null
    }) AND (COALESCE(${
      where?.createdAt ?? null
    }, NULL) IS NULL OR s."createdAt" = ${
      where?.createdAt ?? null
    }) AND (COALESCE(${
      where?.createdAtGreaterThan ?? null
    }, NULL) IS NULL OR s."createdAt" > ${
      where?.createdAtGreaterThan ?? null
    }) AND (COALESCE(${
      where?.createdAtLowerThan ?? null
    }, NULL) IS NULL OR s."createdAt" < ${
      where?.createdAtLowerThan ?? null
    }) AND (COALESCE(${
      where?.updatedAt ?? null
    }, NULL) IS NULL OR s."updatedAt" = ${
      where?.updatedAt ?? null
    }) AND (COALESCE(${
      where?.updatedAtGreaterThan ?? null
    }, NULL) IS NULL OR s."updatedAt" > ${
      where?.updatedAtGreaterThan ?? null
    }) AND (COALESCE(${
      where?.updatedAtLowerThan ?? null
    }, NULL) IS NULL OR s."updatedAt" < ${where?.updatedAtLowerThan ?? null})
`;
    return parseInt(result?.[0]?.genCount ?? "0");
  },

  /**
   * @param {Postgres} sql
   * @param { StoreSessionWhere} [where]
   * @returns {Promise<[]>}
   */
  sessionDelete: (sql, where) => sql`
DELETE FROM "session" s
WHERE (COALESCE(${where?.id ?? null}, NULL) IS NULL OR s."id" = ${
    where?.id ?? null
  }) AND (COALESCE(${
    where?.idIn ?? null
  }, NULL) IS NULL OR s."id" = ANY (${sql.array(
    where?.idIn ?? [],
  )}::uuid[])) AND (COALESCE(${
    where?.expires ?? null
  }, NULL) IS NULL OR s."expires" = ${where?.expires ?? null}) AND (COALESCE(${
    where?.expiresGreaterThan ?? null
  }, NULL) IS NULL OR s."expires" > ${
    where?.expiresGreaterThan ?? null
  }) AND (COALESCE(${
    where?.expiresLowerThan ?? null
  }, NULL) IS NULL OR s."expires" < ${
    where?.expiresLowerThan ?? null
  }) AND (COALESCE(${
    where?.createdAt ?? null
  }, NULL) IS NULL OR s."createdAt" = ${
    where?.createdAt ?? null
  }) AND (COALESCE(${
    where?.createdAtGreaterThan ?? null
  }, NULL) IS NULL OR s."createdAt" > ${
    where?.createdAtGreaterThan ?? null
  }) AND (COALESCE(${
    where?.createdAtLowerThan ?? null
  }, NULL) IS NULL OR s."createdAt" < ${
    where?.createdAtLowerThan ?? null
  }) AND (COALESCE(${
    where?.updatedAt ?? null
  }, NULL) IS NULL OR s."updatedAt" = ${
    where?.updatedAt ?? null
  }) AND (COALESCE(${
    where?.updatedAtGreaterThan ?? null
  }, NULL) IS NULL OR s."updatedAt" > ${
    where?.updatedAtGreaterThan ?? null
  }) AND (COALESCE(${
    where?.updatedAtLowerThan ?? null
  }, NULL) IS NULL OR s."updatedAt" < ${where?.updatedAtLowerThan ?? null})
`,

  /**
   * @param {Postgres} sql
   * @param { StoreSessionInsertPartial_Input|StoreSessionInsertPartial_Input[]} insert
   * @returns {Promise<StoreSession[]>}
   */
  sessionInsert: (sql, insert) => {
    const data = Array.isArray(insert) ? insert : [insert];
    if (data.length === 0) {
      return [];
    }
    let query = `INSERT INTO "session" ("expires", "data", "createdAt", "updatedAt") VALUES `;
    const argList = [];
    let idx = 1;
    for (const it of data) {
      argList.push(
        it.expires ?? null,
        JSON.stringify(it.data ?? {}),
        it.createdAt ?? new Date(),
        it.updatedAt ?? new Date(),
      );
      query += `($${idx++}, $${idx++}, $${idx++}, $${idx++}),`;
    }
    // Remove trailing comma
    query = query.substring(0, query.length - 1);
    query += ` RETURNING "id", "expires", "data", "createdAt", "updatedAt"`;
    return sql.unsafe(query, argList);
  },

  /**
   * @param {Postgres} sql
   * @param { StoreSessionInsertPartial_Input} value
   * @param { StoreSessionWhere} [where]
   * @returns {Promise<StoreSession[]>}
   */
  sessionUpdate: (sql, value, where) => {
    let query = `UPDATE "session" s SET `;
    const argList = [];
    let idx = 1;
    if (value["expires"] !== undefined) {
      query += `"expires" = $${idx++}, `;
      argList.push(value["expires"]);
    }
    if (value["data"] !== undefined) {
      query += `"data" = $${idx++}, `;
      argList.push(JSON.stringify(value["data"]));
    }
    if (value["createdAt"] !== undefined) {
      query += `"createdAt" = $${idx++}, `;
      argList.push(value["createdAt"]);
    }
    query += `"updatedAt" = $${idx++}, `;
    argList.push(new Date());
    query = query.substring(0, query.length - 2);
    query += ` WHERE `;
    if (where.id !== undefined) {
      query += `s."id" `;
      query += `= $${idx++}`;
      argList.push(where.id);
      query += " AND ";
    }
    if (where.idIn !== undefined) {
      query += `s."id" `;
      query += `= ANY (ARRAY[`;
      let addOne = false;
      for (const value of where.idIn || []) {
        addOne = true;
        query += `$${idx++},`;
        argList.push(value);
      }
      query = `${query.substring(
        0,
        query.length - (addOne ? 1 : 0),
      )}]::uuid[])`;
      query += " AND ";
    }
    if (where.expires !== undefined) {
      query += `s."expires" `;
      query += `= $${idx++}`;
      argList.push(where.expires);
      query += " AND ";
    }
    if (where.expiresGreaterThan !== undefined) {
      query += `s."expires" `;
      query += `> $${idx++}`;
      argList.push(where.expiresGreaterThan);
      query += " AND ";
    }
    if (where.expiresLowerThan !== undefined) {
      query += `s."expires" `;
      query += `< $${idx++}`;
      argList.push(where.expiresLowerThan);
      query += " AND ";
    }
    if (where.createdAt !== undefined) {
      query += `s."createdAt" `;
      query += `= $${idx++}`;
      argList.push(where.createdAt);
      query += " AND ";
    }
    if (where.createdAtGreaterThan !== undefined) {
      query += `s."createdAt" `;
      query += `> $${idx++}`;
      argList.push(where.createdAtGreaterThan);
      query += " AND ";
    }
    if (where.createdAtLowerThan !== undefined) {
      query += `s."createdAt" `;
      query += `< $${idx++}`;
      argList.push(where.createdAtLowerThan);
      query += " AND ";
    }
    if (where.updatedAt !== undefined) {
      query += `s."updatedAt" `;
      query += `= $${idx++}`;
      argList.push(where.updatedAt);
      query += " AND ";
    }
    if (where.updatedAtGreaterThan !== undefined) {
      query += `s."updatedAt" `;
      query += `> $${idx++}`;
      argList.push(where.updatedAtGreaterThan);
      query += " AND ";
    }
    if (where.updatedAtLowerThan !== undefined) {
      query += `s."updatedAt" `;
      query += `< $${idx++}`;
      argList.push(where.updatedAtLowerThan);
      query += " AND ";
    }
    query = query.substring(0, query.length - 4);
    query += ` RETURNING s."id", s."expires", s."data", s."createdAt", s."updatedAt"`;
    return sql.unsafe(query, argList);
  },

  /**
   * Note: Use only when id has a unique constraint
   * @param {Postgres} sql
   * @param { StoreSessionInsertPartial_Input & { id?: string } } it
   * @returns {Promise<StoreSession[]>}
   */
  sessionUpsert: (sql, it) => {
    return sql`
INSERT INTO "session" ("id", "expires", "data", "createdAt", "updatedAt"
) VALUES (
${it.id ?? uuid()}, ${it.expires ?? null}, ${JSON.stringify(it.data ?? {})}, ${
      it.createdAt ?? new Date()
    }, ${it.updatedAt ?? new Date()}
) ON CONFLICT("id") DO UPDATE SET
"expires" = EXCLUDED."expires", "data" = EXCLUDED."data", "updatedAt" = EXCLUDED."updatedAt"
RETURNING "id", "expires", "data", "createdAt", "updatedAt"
`;
  },

  /**
   * Note: Use only when expires has a unique constraint
   * @param {Postgres} sql
   * @param { StoreSessionInsertPartial_Input & { id?: string } } it
   * @returns {Promise<StoreSession[]>}
   */
  sessionUpsertByExpires: (sql, it) => {
    return sql`
INSERT INTO "session" ("id", "expires", "data", "createdAt", "updatedAt"
) VALUES (
${it.id ?? uuid()}, ${it.expires ?? null}, ${JSON.stringify(it.data ?? {})}, ${
      it.createdAt ?? new Date()
    }, ${it.updatedAt ?? new Date()}
) ON CONFLICT("expires") DO UPDATE SET
"data" = EXCLUDED."data", "updatedAt" = EXCLUDED."updatedAt"
RETURNING "id", "expires", "data", "createdAt", "updatedAt"
`;
  },

  /**
   * Note: Use only when createdAt has a unique constraint
   * @param {Postgres} sql
   * @param { StoreSessionInsertPartial_Input & { id?: string } } it
   * @returns {Promise<StoreSession[]>}
   */
  sessionUpsertByCreatedAt: (sql, it) => {
    return sql`
INSERT INTO "session" ("id", "expires", "data", "createdAt", "updatedAt"
) VALUES (
${it.id ?? uuid()}, ${it.expires ?? null}, ${JSON.stringify(it.data ?? {})}, ${
      it.createdAt ?? new Date()
    }, ${it.updatedAt ?? new Date()}
) ON CONFLICT("createdAt") DO UPDATE SET
"expires" = EXCLUDED."expires", "data" = EXCLUDED."data", "updatedAt" = EXCLUDED."updatedAt"
RETURNING "id", "expires", "data", "createdAt", "updatedAt"
`;
  },

  /**
   * Note: Use only when updatedAt has a unique constraint
   * @param {Postgres} sql
   * @param { StoreSessionInsertPartial_Input & { id?: string } } it
   * @returns {Promise<StoreSession[]>}
   */
  sessionUpsertByUpdatedAt: (sql, it) => {
    return sql`
INSERT INTO "session" ("id", "expires", "data", "createdAt", "updatedAt"
) VALUES (
${it.id ?? uuid()}, ${it.expires ?? null}, ${JSON.stringify(it.data ?? {})}, ${
      it.createdAt ?? new Date()
    }, ${it.updatedAt ?? new Date()}
) ON CONFLICT("updatedAt") DO UPDATE SET
"expires" = EXCLUDED."expires", "data" = EXCLUDED."data"
RETURNING "id", "expires", "data", "createdAt", "updatedAt"
`;
  },
};
