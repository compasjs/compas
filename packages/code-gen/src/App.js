import { newLogger, printProcessMemoryUsage } from "@lbu/insight";
import { isNil, isPlainObject, newTemplateContext } from "@lbu/stdlib";
import { inspect } from "util";
import {
  addToData,
  callGeneratorMethod,
  hoistNamedItems,
  runGenerators,
} from "./generate.js";
import { TypeCreator } from "./types/index.js";
import { lowerCaseFirst, upperCaseFirst } from "./utils.js";

/**
 * @name AppOpts
 *
 * @typedef {object}
 * @property {GeneratorPlugin[]} generators
 * @property {boolean} [verbose]
 */

/**
 * @name GeneratorPlugin
 *
 * @typedef {object}
 * @property {string} name
 * @property {function(App): void|Promise<void>} [init]
 * @property {function(App, GenerateOpts): void|Promise<void>} [preGenerate]
 * @property {function(App, GenerateOpts, object):
 *   GeneratedFile[]|GeneratedFile|Promise<GeneratedFile[]|GeneratedFile>} [generate]
 */

/**
 * @name GeneratedFile
 *
 * @typedef {object}
 * @property {string} path
 * @property {string} source
 */

/**
 * The entry-point to code generation
 * Provides the structure for creating types, and extending with external sources.
 * Also maintains the generators
 *
 * @class
 */
export class App {
  /**
   * @param {AppOpts} options
   */
  constructor({ verbose, generators }) {
    /**
     * @public
     * @type {Map<string, GeneratorPlugin>}
     */
    this.generators = new Map();

    this.fileHeader = `// Generated by @lbu/code-gen
/* eslint-disable no-unused-vars, jsdoc/valid-types, jsdoc/require-returns-description, jsdoc/no-undefined-types, jsdoc/require-property-description */
`;

    /**
     * @public
     * @type {boolean}
     */
    this.verbose = verbose || false;

    /**
     * @public
     * @type {Logger}
     */
    this.logger = newLogger({
      ctx: {
        type: "code_gen",
      },
      depth: 4,
    });

    /**
     * @public
     * @type {TemplateContext}
     */
    this.templateContext = newTemplateContext();
    this.templateContext.strict = false;

    /** @type {Set<TypeBuilder>} */
    this.unprocessedData = new Set();

    /** @type {{structure: object<key, object<key, object>>}} */
    this.data = {
      structure: {},
    };

    this._generatorList = generators;
  }

  /**
   * Init generators and validate types
   *
   * @returns {Promise<void>}
   */
  async init() {
    this.templateContext.globals["upperCaseFirst"] = upperCaseFirst;
    this.templateContext.globals["lowerCaseFirst"] = lowerCaseFirst;
    this.templateContext.globals["inspect"] = (arg) =>
      inspect(arg, { sorted: true, colors: false });

    for (const g of this._generatorList) {
      if (isNil(g.name)) {
        throw new Error("Generator is missing name");
      }

      this.generators.set(g.name, g);
    }

    if (this.verbose) {
      this.logger.info({
        msg: "Registered plugins: ",
        generators: [...this.generators.keys()],
        types: [...TypeCreator.types.keys()],
      });
    }

    await callGeneratorMethod(this, this.generators.keys(), "init");
  }

  /**
   * @public
   * @param {...TypeBuilder} builders
   * @returns {this}
   */
  add(...builders) {
    for (const builder of builders) {
      this.unprocessedData.add(builder);
    }

    return this;
  }

  /**
   * @public
   * @param data
   */
  extend(data) {
    if (!isPlainObject(data)) {
      throw new Error(`data should be an object.`);
    }

    for (const groupData of Object.values(data)) {
      for (const item of Object.values(groupData)) {
        this.addToData(item);
      }
    }
  }

  /**
   * @param {GenerateOpts} options
   * @returns {Promise<void>}
   */
  async generate(options) {
    if (isNil(options?.outputDirectory)) {
      throw new Error("Need options.outputDirectory to write files to.");
    }
    options.fileHeader = this.fileHeader + (options.fileHeader ?? "");
    options.useTypescript = !!options.useTypescript;
    options.dumpStructure = !!options.dumpStructure;
    options.useStubGenerators = !!options.useStubGenerators;
    options.enabledGenerators = options.enabledGenerators || [
      ...this.generators.keys(),
    ];

    this.processData();
    hoistNamedItems(this.data, this.data.structure);

    options.enabledGroups =
      options.enabledGroups || Object.keys(this.data.structure);
    if (options.enabledGroups.length === 0) {
      throw new Error("Need at least a single group in enabledGroups");
    }

    await runGenerators(this, options);
    printProcessMemoryUsage(this.logger);
  }

  /**
   * Process unprocessed list, normalize references
   * Depends on referentType being available
   *
   * @private
   */
  processData() {
    for (const item of this.unprocessedData) {
      const result = item.build();
      this.addToData(result);
    }
    this.unprocessedData.clear();
  }

  /**
   * @private
   * @param item
   */
  addToData(item) {
    addToData(this.data, item);
  }
}
