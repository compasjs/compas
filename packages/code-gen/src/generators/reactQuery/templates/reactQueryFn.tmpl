{{ /* Keep in sync with apiClientFn */ }}
{{ const funcName = "use" + upperCaseFirst(model.uniqueName); }}
{{ const getRef = (model) => /* Recursively resolve references */ { const ref = !!model && structure[model.group][model.name]; if (ref && ref.reference) { return getRef(ref.reference); } else { return ref; } }; }}

{{ let responseType = undefined; }}
{{ if (model.response && getItem(model.response).type !== "file") { }}
{{ responseType = `T.${model.response.reference.uniqueName}`; }}
{{ } else if (model.response) { }}
{{ responseType = "Blob"; }}
{{ } else { }}
{{ responseType = "any"; }}
{{ } }}

{{ if (model.method === "GET") { }}

((newline))
/**
 * {{= funcName }}
 * Tags: {{= model.tags.join(", ") }}
 * Docs: {{= model.docString.replace(/\n/g, "\n  * ") }}
 */
export function {{= funcName }}(
{{ if (model.params) { }}
params: {{= "T." + model.params.reference.uniqueName + "_Input" }},
{{ } }}
{{ if (model.query) { }}
query: T.{{= model.query.reference.uniqueName }}_Input,
{{ } }}
options: QueryOptions<{{=  responseType }}, AppErrorResponse> = {},
): QueryResult<{{= responseType }}, AppErrorResponse> {
  options.enabled = (
    (options.enabled !== false && options.enabled !== undefined)
    {{ if (model.query && getRef(model.query.reference)) { }}
      {{ const ref = getRef(model.query.reference); }}
      {{ for (const key of Object.keys(ref?.keys ?? {})) { }}
        {{ if (!ref.keys[key].isOptional) { }}
          || !!query.{{= key }}
        {{ } }}
      {{ } }}
    {{ } }}
    {{ if (model.params && getRef(model.params.reference)) { }}
      {{ const ref = getRef(model.params.reference); }}
      {{ for (const key of Object.keys(ref?.keys ?? {})) { }}
        {{ if (!ref.keys[key].isOptional) { }}
          || !!params.{{= key }}
        {{ } }}
      {{ } }}
    {{ } }}
  );

  return useQuery([
     "{{= model.uniqueName }}",

    {{ if (model.params) { }}
    params,
    {{ } }}
    {{ if (model.query) { }}
    query,
    {{ } }}
    ],
    (
    _,
    {{ if (model.params) { }}
    params,
    {{ } }}
    {{ if (model.query) { }}
    query,
    {{ } }}
    ) => {{= model.group }}Api.{{= model.name }}(
      {{= model.params ? "params, " : ""}}
      {{= model.query ? "query, " : "" }}
    ),
    options,
  );
}

{{ } else { }}

interface {{= upperCaseFirst(funcName) }}Props {
   {{ if (model.params) { }}
   params: {{= model.params ? "T." + model.params.reference.uniqueName + "_Input" : "object" }}
   {{ } }}
   {{ if (model.query) { }}
    query: T.{{= model.query.reference.uniqueName }}_Input
   {{ } }}
   {{ if (model.body) { }}
   body: T.{{= model.body.reference.uniqueName }}_Input
   {{ } }}
   {{ if (model.files) { }}
   files: T.{{= model.files.reference.uniqueName }}_Input
   {{ } }}
}

((newline))

/**
 * {{= funcName }}
 * Tags: {{= model.tags.join(", ") }}
 * Docs: {{= model.docString }}
 */
export function {{= funcName }}(
  options: MutationOptions<{{= responseType }}, {{= upperCaseFirst(funcName) }}Props, AppErrorResponse> = {},
): [MutateFunction<{{= responseType }}, {{= upperCaseFirst(funcName) }}Props, AppErrorResponse>, MutationResult<{{= responseType }}, AppErrorResponse>] {
  return useMutation(
    (variables) => {{= model.group }}Api.{{= model.name }}(
      {{= model.params ? "variables.params, " : ""}}
      {{= model.query ? "variables.query, " : "" }}
      {{= model.body ? "variables.body, " : "" }}
      {{= model.files ? "variables.files, " : "" }}
    ),
    options,
  );
}

{{ } }}

((newline))
