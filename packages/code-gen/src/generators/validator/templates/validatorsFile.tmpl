{{= options.fileHeader }}
((newline))

export const validatorHooks = {};
((newline))

const isNil = value => value === undefined || value === null;
((newline))

/**
 * This function should not throw as the corresponding validator will do that
 * @callback ValidationErrorFn
 * @param {string} key
 * @param {Object} info
 */
((newline))

/**
 * @type ValidationErrorFn
 */
let _errorFn = (key, info) => {
  const err = new Error(`ValidationError: ${key}`);
  err.key = key;
  err.info = info;

  return err;
}
((newline))

/**
 * Set a different error function, for example AppError.validationError
 * @param {ValidationErrorFn} fn
 */
export function validatorSetErrorFn(fn) {
  _errorFn = fn;
}
((newline))

{{ const ctx = { counter: 0, functions: [], memo: new Map() }; }}
{{ ctx.addFunc = fn => { ctx.functions.push(fn); }; }}
{{ ctx.anonFn = (model) => { const key = inspect(model); if (!ctx.memo.has(key)) { const nr = ctx.counter; ctx.addFunc(validatorsAnonFn({ model, ctx })); ctx.memo.set(key, nr); } return ctx.memo.get(key); }; }}

{{ for (const groupName of Object.keys(structure)) { }}

  export const {{= groupName }}Validators = {
((newline))

  {{ for (const itemName of Object.keys(structure[groupName])) { }}
    {{ const item = structure[groupName][itemName]; }}

    {{ if (options.validator_enabledTypes.indexOf(item.type) === -1) { }}
    {{ continue; }}
    {{ } }}

    {{ if (item?.disabled?.validator) { }}
    {{ continue; }}
    {{ } }}

    {{= validatorsNamedFn({ ctx, model: item }) }}
((newline))

  {{ } }}

  };
((newline))

{{ } }}

{{= ctx.functions.join("\n") }}
((newline))
