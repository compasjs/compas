{{= options.fileHeader }}
((newline))

import { isNil, uuid } from "@lbu/stdlib";
((newline))


{{ for (const groupName of Object.keys(structure)) { }}

  export const {{= groupName }}Queries = {
((newline))

  {{ for (const itemName of Object.keys(structure[groupName])) { }}
    {{ const item = structure[groupName][itemName]; }}

    {{ if (item.type !== "sql") { }}
    {{ continue; }}
    {{ } }}

    {{ const ref = structure[item.original.group][item.original.name]; }}
    {{ const getKeys = (shortName) => Object.keys(ref.keys).map(it => shortName + camelToSnakeCase(it) + ` as "` + it + `"`).join(", "); }}

   /**
    * @param sql
    * @param { {{= ref.uniqueName }}Where} where
    * @return {Promise<{{= ref.uniqueName }}[]>}
    */
    {{= ref.name }}Select: (sql, where) => sql`SELECT {{= getKeys(item.shortName + ".") }} FROM {{= camelToSnakeCase(ref.name) }} {{= item.shortName }} {{= sqlWhereClause({ item, ref }) }}`,
((newline))

    /**
    * @param sql
    * @param { {{= ref.uniqueName }}Where} where
    * @return {Promise<number>}
    */
    {{= ref.name }}Count: async (sql, where) => {
      const result = await sql`SELECT count(*) as gen_count FROM {{= camelToSnakeCase(ref.name) }} {{= item.shortName }} {{= sqlWhereClause({ item, ref }) }}`;

      return result?.[0]?.gen_count ?? 0;
    },
((newline))

    /**
    * @param sql
    * @param { {{= ref.uniqueName }}Where} where
    * @return {Promise<*[]>}
    */
    {{= ref.name }}Delete: (sql, where) => sql`DELETE FROM {{= camelToSnakeCase(ref.name) }} {{= item.shortName }} {{= sqlWhereClause({ item, ref }) }}`,
((newline))

    /**
     * @param sql
     * @param { {{= ref.uniqueName }}InsertPartial_Input|{{= ref.uniqueName }}InsertPartial_Input[]} insert
     * @return {Promise<{{= ref.uniqueName }}[]>}
     */
    {{= ref.name }}Insert: (sql, insert) => {
      const data = Array.isArray(insert) ? insert : [insert];
      const input = [];
      for (const it of data) {
        input.push({{= sqlGenDefaults({ item, ref, }) }} );
      }

      return sql`INSERT INTO {{= camelToSnakeCase(ref.name) }} ${sql(input, {{= item.partialFields.map(it => "'" + it.result + "'").join(", ") }} )} RETURNING {{= getKeys("") }}`;
    },
((newline))

    /**
     * @param sql
     * @param { {{= ref.uniqueName }}InsertPartial_Input} value
     * @param { {{= ref.uniqueName }}Where} where
     * @return {Promise<{{= ref.uniqueName }}[]>}
     */
    {{= ref.name }}Update: {{ if (ref.queryOptions.withHistory) { }} async {{ } }}(sql, value, where) => {
      const updateValue = {};
      {{ for (const key of item.partialFields) { }}
      if (!isNil(value["{{= key.source }}"])) {
        updateValue["{{= key.result }}"] = value["{{= key.source }}"];
      }
      {{ } }}

      {{ if (ref.queryOptions.dateFields) { }}
      updateValue.updated_at = new Date();
      {{ } }}
      {{ if (ref.queryOptions.withHistory) { }}
      await sql`INSERT INTO {{= camelToSnakeCase(ref.name) }}_history ({{= camelToSnakeCase(ref.name) }}_id, {{= item.partialFields.map(it => it.result).filter(it => it !== "created_at" && it !== "updated_at").join(", ") }}, created_at)
      SELECT id, {{= item.partialFields.map(it => it.result).filter(it => it !== "created_at" && it !== "updated_at").join(", ") }}, COALESCE(updated_at, created_at, now()) FROM {{= camelToSnakeCase(ref.name) }} {{= item.shortName }} {{= sqlWhereClause({ item, ref }) }}
      `;
      {{ } }}
      return sql`UPDATE {{= camelToSnakeCase(ref.name) }} {{= item.shortName }} set ${sql(updateValue, ...Object.keys(updateValue))} {{= sqlWhereClause({ item, ref }) }} RETURNING {{= getKeys(item.shortName + ".") }}`;
    },
((newline))

    {{ if (!ref.queryOptions.withHistory) { }}
    /**
     * @param sql
     * @param { {{= ref.uniqueName }}InsertPartial_Input & { id?: {{= typeExec({ type: ref.keys["id"].type, model: ref.keys["id"], isInputType: true }).trim() }} } } it
     * @return {Promise<{{= ref.uniqueName }}[]>}
     */
     {{= ref.name }}Upsert: (sql, it) => {
       const data = {{= sqlGenDefaults({ item, ref, }) }};
       data.id = it.id || uuid();
       return sql`INSERT INTO {{= camelToSnakeCase(ref.name) }} ${sql(data, "id", {{= item.partialFields.map(it => "'" + it.result + "'").join(", ") }} )} ON CONFLICT (id) DO UPDATE SET ${sql(data, {{= item.partialFields.map(it => "'" + it.result + "'").join(", ") }} )} RETURNING {{= getKeys("") }}`
     },
((newline))

    {{ } }}

    {{ if (ref.queryOptions.withHistory) { }}
   /**
    * @param sql
    * @param { {{= ref.uniqueName }}Where} where
    * @return {Promise<({{= ref.uniqueName }} & (history: {{= ref.uniqueName }}[]))[]>}
    */
    {{= ref.name }}SelectHistory: (sql, where) => sql`SELECT {{= getKeys(item.shortName + ".") }}, array_agg({{= item.shortName }}h.*) as history FROM {{= camelToSnakeCase(ref.name) }} {{= item.shortName }} LEFT JOIN  {{= camelToSnakeCase(ref.name) }}_history {{= item.shortName }}h ON {{= item.shortName }}.id = {{= item.shortName }}h.{{= camelToSnakeCase(ref.name) }}_id {{= sqlWhereClause({ item, ref }) }} GROUP BY {{= item.shortName }}.id`,
((newline))

    {{ } }}


  {{ } }}

  };
((newline))

{{ } }}
