{{= options.fileHeader }}
((newline))

import { uuid } from "@lbu/stdlib";
((newline))


{{ for (const groupName of Object.keys(structure)) { }}

  export const {{= groupName }}Queries = {
((newline))

  {{ for (const itemName of Object.keys(structure[groupName])) { }}
    {{ const item = structure[groupName][itemName]; }}

    {{ if (item.type !== "sql") { }}
    {{ continue; }}
    {{ } }}

    {{ const ref = structure[item.original.group][item.original.name]; }}
    {{ const getKeys = (shortName) => Object.keys(ref.keys).map(it => `${shortName}"${it}"`).join(", "); }}

   /**
    * @param sql
    * @param { {{= ref.uniqueName }}Where} [where]
    * @returns {Promise<{{= ref.uniqueName }}[]>}
    */
    {{= ref.name }}Select: (sql, where) => sql`
    SELECT
      {{= getKeys(item.shortName + ".") }}
    FROM "{{= ref.name }}" {{= item.shortName }}
    {{= sqlWhereClause({ item, ref, variable: "where" }) }}
    {{= sqlOrderBy({ item, ref }) }}
    `,
((newline))

   {{ for (const relation of item.relations) { }}

     {{ const subItem = structure[relation.rightGroup][relation.rightName + "Sql"]; }}
     {{ const subRef = structure[relation.rightGroup][relation.rightName]; }}


     /**
      * @param sql
      * @param { {{= upperCaseFirst(relation.whereType) }} } [where]
      * @returns {Promise<{{= upperCaseFirst(item.group) + upperCaseFirst(relation.name) }}[]>}
      */
     {{= relation.selectName }}: (sql, where) =>  sql`

     {{ if (relation.type === "manyToOne") { }}

       SELECT
        {{= getKeys(item.shortName + ".") }}, to_jsonb({{= relation.rightShortName }}.*) AS "{{= relation.substituteKey }}"
       FROM "{{= ref.name }}" {{= item.shortName }}
       LEFT JOIN (
         SELECT * FROM "{{= relation.rightName }}" {{= relation.rightShortName }}
         {{= sqlWhereClause({ item: subItem, ref: subRef, variable: `where?.${relation.substituteKey}` }) }}
         {{= sqlOrderBy({ item: subItem, ref: subRef }) }}
       ) {{= relation.rightShortName }}
         ON {{= item.shortName }}."{{= relation.leftKey }}" = {{= relation.rightShortName }}."{{= relation.rightKey }}"
       {{= sqlWhereClause({ item, ref, variable: "where", skipKeys: [relation.substituteKey, relation.substituteKey + "In", relation.substituteKey + "Like"] }) }}
       {{= sqlOrderBy({ item, ref }) }}
       `,
     {{ } else if (relation.type === "oneToMany") { }}

       SELECT
        {{= getKeys(item.shortName + ".") }}, array_remove(array_agg(to_jsonb({{= relation.rightShortName }}.*)), NULL) AS "{{= relation.substituteKey }}"
       FROM "{{= ref.name }}" {{= item.shortName }}
       LEFT JOIN (
         SELECT *
         FROM "{{= relation.rightName }}" {{= relation.rightShortName }}
         {{= sqlWhereClause({ item: subItem, ref: subRef, variable: `where?.${relation.substituteKey}` }) }}
         {{= sqlOrderBy({ item: subItem, ref: subRef }) }}
       ) {{= relation.rightShortName }}
         ON {{= item.shortName }}."{{= relation.leftKey }}" = {{= relation.rightShortName }}."{{= relation.rightKey }}"
       {{= sqlWhereClause({ item, ref, variable: "where", skipKeys: [relation.substituteKey, relation.substituteKey + "In", relation.substituteKey + "Like"] }) }}
       GROUP BY {{= item.shortName }}."{{= relation.leftKey }}"
       {{= sqlOrderBy({ item, ref }) }}
        `,

     {{ } }}
((newline))
   {{ } }}

    /**
    * @param sql
    * @param { {{= ref.uniqueName }}Where} [where]
    * @returns {Promise<number>}
    */
    {{= ref.name }}Count: async (sql, where) => {
      const result = await sql`
      SELECT count(*) AS "genCount" FROM "{{= ref.name }}" {{= item.shortName }} {{= sqlWhereClause({ item, ref, variable: "where" }) }}
      `;

      return parseInt(result?.[0]?.genCount ?? "0");
    },
((newline))

    /**
    * @param sql
    * @param { {{= ref.uniqueName }}Where} [where]
    * @returns {Promise<*[]>}
    */
    {{= ref.name }}Delete: (sql, where) => sql`
    DELETE FROM "{{= ref.name }}" {{= item.shortName }} {{= sqlWhereClause({ item, ref, variable: "where" }) }}
    `,
((newline))

    /**
     * @param sql
     * @param { {{= ref.uniqueName }}InsertPartial_Input|{{= ref.uniqueName }}InsertPartial_Input[]} insert
     * @returns {Promise<{{= ref.uniqueName }}[]>}
     */
    {{= ref.name }}Insert: (sql, insert) => {
      const data = Array.isArray(insert) ? insert : [insert];
      if (data.length === 0) {
        {{ /* No input so no result as well */ }}
        return [];
      }

      let query = `INSERT INTO "{{= ref.name }}" ({{= item.partialFields.map(it => `"${it.source}"`).join(", ") }}) VALUES `;
      const argList = [];
      let idx = 1;

      for (const it of data) {
        argList.push({{= item.partialFields.map(it => sqlGenDefaults({ field: it, ref })).join(", ") }});
        query += `({{= item.partialFields.map(it => "$${idx++}").join(", ") }}),`;
      }

      // Remove trailing comma
      query = query.substring(0, query.length - 1)
      query += ` RETURNING {{= getKeys("") }}`

      return sql.unsafe(query, argList);
    },
((newline))

    /**
     * @param sql
     * @param { {{= ref.uniqueName }}InsertPartial_Input} value
     * @param { {{= ref.uniqueName }}Where} [where]
     * @returns {Promise<{{= ref.uniqueName }}[]>}
     */
    {{= ref.name }}Update: {{ if (ref.queryOptions.withHistory) { }} async {{ } }}(sql, value, where) => {
      {{ if (ref.queryOptions.withHistory) { }}
      await sql`
      INSERT INTO "{{= ref.name }}History" ("{{= ref.name }}Id", {{= item.partialFields.filter(it => it.source !== "createdAt" && it.source !== "updatedAt").map(it => `"${it.source}"`).join(", ") }}, "createdAt")
      SELECT id, {{= item.partialFields.filter(it => it.source !== "createdAt" && it.source !== "updatedAt").map(it => `"${it.source}"`).join(", ") }}, COALESCE("updatedAt", "createdAt", now()) FROM "{{= ref.name }}" {{= item.shortName }} {{= sqlWhereClause({ item, ref, variable: "where" }) }}
      `;
      {{ } }}

      let query = `UPDATE "{{= ref.name }}" {{= item.shortName }} SET `;
      const argList = [];
      let idx = 1;

      {{ for (const key of item.partialFields.filter(it => it.source !== "updatedAt")) { }}
        if (value["{{= key.source }}"] !== undefined) {
          query += `"{{= key.source }}" = $${idx++}, `
          argList.push({{= key.stringify ? `JSON.stringify(value["${key.source}"])` : `value["${key.source}"]` }});
        }
      {{ } }}

     {{ if (ref.queryOptions.dateFields) { }}
       query += `"updatedAt" = $${idx++}, `;
       argList.push(new Date());
     {{ } }}

     query = query.substring(0, query.length - 2);

     {{= sqlWhereClauseUnsafe({ item, ref }) }}

     query += ` RETURNING {{= getKeys(item.shortName + ".") }}`

     return sql.unsafe(query, argList);
    },
((newline))

    {{ if (!ref.queryOptions.withHistory) { }}
        {{ for (const field of item.whereFields.filter(it => it.type === "equal")) { }}

            /**
             * Note: Use only when {{= field.key }} has a unique constraint
             * @param sql
             * @param { {{= ref.uniqueName }}InsertPartial_Input & { id?: {{= typeExec({ type: ref.keys["id"].type, model: ref.keys["id"], isInputType: true }).trim() }} } } it
             * @returns {Promise<{{= ref.uniqueName }}[]>}
             */
             {{= ref.name }}Upsert{{= field.key === "id" ? "" : "By" + upperCaseFirst(field.key) }}: (sql, it) => {
              return sql`
                INSERT INTO "{{= ref.name }}" ("id", {{= item.partialFields.map(it => `"${it.source}"`).join(", ") }}
                ) VALUES (
                 ${it.id ?? uuid()}, {{= item.partialFields.map(it => `\${${sqlGenDefaults({ field: it, ref }) } }`).join(", ") }}
                ) ON CONFLICT("{{= field.key }}") DO UPDATE SET
                  {{= item.partialFields.filter(it => it.source !== field.key && it.source !== "createdAt").map(it => `"${it.source}" = EXCLUDED."${it.source}"`).join(", ") }}
                RETURNING {{= getKeys("") }}
              `;
             },

         ((newline))
        {{ } }}
    {{ } }}

    {{ if (ref.queryOptions.withHistory) { }}
   /**
    * @param sql
    * @param { {{= ref.uniqueName }}Where} [where]
    * @returns {Promise<({{= ref.uniqueName }} & (history: {{= ref.uniqueName }}[]))[]>}
    */
    {{= ref.name }}SelectHistory: (sql, where) => sql`
    SELECT
     {{= getKeys(item.shortName + ".") }}, array_agg(to_jsonb({{= item.shortName }}h.*)) AS history
    FROM "{{= ref.name }}" {{= item.shortName }}
    LEFT JOIN "{{= ref.name }}History" {{= item.shortName }}h ON {{= item.shortName }}.id = {{= item.shortName }}h."{{= ref.name }}Id"
    {{= sqlWhereClause({ item, ref, variable: "where" }) }}
    GROUP BY {{= item.shortName }}.id
    {{= sqlOrderBy({ item, ref }) }}
    `,
((newline))

    {{ } }}
  {{ } }}

  };
((newline))

{{ } }}
