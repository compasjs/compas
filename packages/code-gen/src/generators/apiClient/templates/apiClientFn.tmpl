{{ const url = item.path.split("/").map(part => { if (part.startsWith(":")) { return "${params." + part.substring(1) + "}"; } else { return part; } }).join("/"); }}
{{ const buildTypeQualifier = (type, inputType) => `${options.useTypescript ? 'import("./types").'  : ""}${type.uniqueName}${inputType ? "_Input" : ""}`; }}

/**
 * {{= item.uniqueName }}
 {{ if (item.tags.length > 0 ) { }}* Tags: {{= item.tags.join(", ") }}{{ } }}
 * Docs: {{= item.docString }}
{{ if (item.params) { }}
 * @param { {{= buildTypeQualifier(getItem(item.params), true) }} } params
{{ } }}
{{ if (item.query) { }}
 * @param { {{= buildTypeQualifier(getItem(item.query), true) }} } query
{{ } }}
{{ if (item.body) { }}
 * @param { {{= buildTypeQualifier(getItem(item.body), true) }} } body
{{ } }}
{{ if (item.files) { }}
 * @param { {{= buildTypeQualifier(getItem(item.files), true) }} } files
{{ } }}
{{ if (options.isBrowser) { }}
 * @param { { cancelToken?: CancelToken } } [options]
{{ } }}
{{ if (item.response) { }}
 * @returns {Promise<{{= buildTypeQualifier(getItem(item.response), false) }}>}
{{ } else { }}
 * @returns {Promise.<*>}
{{ } }}

 */
{{= item.name }}: async function (
{{ if (item.params) { }}
params,
{{ } }}
{{ if (item.query) { }}
query,
{{ } }}
{{ if (item.body) { }}
body,
{{ } }}
{{ if (item.files) { }}
files,
{{ } }}
{{ if (options.isBrowser) { }}
options = {},
{{ } }}
) {
    {{ if (!options.isBrowser) { }}
    checkApiClient();
    {{ } }}

    {{ if (item.files) { }}
      // eslint-disable-next-line
      const data = new FormData();
      for (const key of Object.keys(files)) {
        const keyFiles = Array.isArray(files[key]) ? files[key] : [files[key]];
        for (const file of keyFiles) {
          data.append(key, file.data, file.name);
        }
      }
    {{ } else if (item.body) { }}
      const data = body;
    {{ } }}

    {{ if (options.isNodeServer) { }}
    try {
    {{ } }}

    const response = await _internalClient.request({
      url: `{{= url }}`,
      method: "{{= item.method.toLowerCase() }}",
      params: {{ if (item.query) { }}query{{ } else { }}{}{{ } }},
      data: {{ if (item.body || item.files) { }}data{{ } else { }}{}{{ } }},
      {{ if (item.files && options.isNode) { }}
      headers: data.getHeaders(),
      {{ } }}
      {{ if (item.response && getItem(item.response).type === "file") { }}
      responseType: "{{= options.isNode ? "stream" : "blob" }}",
      {{ } }}
      {{ if (options.isBrowser) { }}
      cancelToken: options?.cancelToken,
      {{ } }}
    });

    {{ if (!options.isNodeServer) { }}
      return response.data;
    {{ } else { }}
      {{ if (item.response) { }}
        {{ const { name, group } = getItem(item.response); }}
        {{ /* Validates response, but does not use the validated result. This implies that dates will be ISO strings, and objects don't have a 'null' prototype. */ }}
        validators.{{= group }}Validators.{{= name }}(response.data);
      {{ } }}
      return response.data;
    } catch (e) {
      handleError(e, "{{= item.group }}", "{{= item.name }}");
    }

    {{ } }}

},
((newline))
