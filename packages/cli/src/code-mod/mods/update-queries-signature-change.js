// @ts-nocheck

import { readFile, writeFile } from "fs/promises";
import { AppError, processDirectoryRecursive } from "@compas/stdlib";
import * as recast from "recast";
import { PARALLEL_COUNT } from "../constants.js";

/**
 * Convert `queries.entitySelect(sql, { ...where })` to `queryEntity({ where: { ...where
 * } }).exec(sql)`
 *
 * @param {Logger} logger
 * @returns {Promise<void>}
 */
export async function executeUpdateQueriesSignatureChange(logger) {
  const generatedFileList = await listGeneratedEntityFiles();
  const fullFileList = await listAllJavaScriptFiles(generatedFileList);

  const { callCount, fileCount, possibleInvalidCalls } = await modTheFiles(
    fullFileList,
  );

  logger.info(`Converted ${callCount} occurrences in ${fileCount} files.`);

  if (possibleInvalidCalls.length > 0) {
    for (const invalidCall of possibleInvalidCalls) {
      logger.info(
        `Found a possible invalid usage that is not transformed at '${invalidCall}'.`,
      );
    }
  }
}

/**
 * Find generated database files
 *
 * @returns {Promise<string[]>}
 */
async function listGeneratedEntityFiles() {
  const possibleFileList = [];

  await processDirectoryRecursive(process.cwd(), (file) => {
    if (file.match(/database\/\w+\.js$/gi) && !file.endsWith("index.js")) {
      possibleFileList.push(file);
    }
  });

  const result = [];

  // Double check that these files are generated
  while (possibleFileList.length) {
    const partial = possibleFileList.splice(0, PARALLEL_COUNT);

    await Promise.all(
      partial.map(async (file) => {
        const contents = await readFile(file, "utf-8");

        if (contents.startsWith("// Generated by @compas/code-gen")) {
          result.push(file);
        }
      }),
    );
  }

  return result;
}

/**
 * Find all js files, excluding the generated ones
 *
 * @param {string[]} generatedFiles
 * @returns {Promise<string[]>}
 */
async function listAllJavaScriptFiles(generatedFiles) {
  const result = [];

  await processDirectoryRecursive(process.cwd(), (file) => {
    if (!file.endsWith(".js")) {
      return;
    }

    if (generatedFiles.includes(file)) {
      return;
    }

    result.push(file);
  });

  return result;
}

/**
 * Replace the call-sites
 *
 * @param {string[]} fileList
 * @returns {Promise<{ callCount: number, fileCount: number, possibleInvalidCalls:
 *   string[] }>}
 */
async function modTheFiles(fileList) {
  const builders = recast.types.builders;

  const filesToWrite = {};
  let replaceCount = 0;
  let modifiedFileCount = 0;
  const possibleInvalidCalls = [];

  while (fileList.length) {
    const partial = fileList.splice(0, PARALLEL_COUNT);

    await Promise.all(
      partial.map(async (file) => {
        let didReplace = false;
        const contents = await readFile(file, "utf-8");

        // We only supported destructured 'queries' imports, so skip parsing if the file
        // doesn't include such an instance.
        if (!contents.includes("queries")) {
          return;
        }

        const ast = await parseFile(file, contents);

        // Cases;
        // Input: await queries.bbbUpdate(sql, update, where);
        // Output: await queries.bbbUpdate(sql, { update, where });

        // Input: const result = await queries.bbbUpdate(sql, update, where);
        // Output: const result = await queries.bbbUpdate(sql, {update, where, returning:
        // "*" });
        recast.visit(ast, {
          visitCallExpression(path) {
            if (path.node.callee.type !== "MemberExpression") {
              this.traverse(path);
              return;
            }

            // Check if object is a 'queries'
            if (path.node.callee.object.name !== "queries") {
              this.traverse(path);
              return;
            }

            // Check if .property is an entityUpdate()
            if (!/^\w+Update$/g.test(path.node.callee.property.name)) {
              this.traverse(path);
              return;
            }

            if (path.node.arguments.length !== 3) {
              possibleInvalidCalls.push(
                `${file}:${path.node.loc.start.line}:${path.node.loc.start.column}`,
              );

              this.traverse(path);
              return;
            }

            const resultIsUsed =
              path.parent.parent.value.type === "VariableDeclarator" ||
              path.parent.parent.value.type !== "ExpressionStatement";

            // Replace call
            const sql = path.node.arguments[0];
            let update = path.node.arguments[1];
            let where = path.node.arguments[2];

            if (update.type === "ObjectExpression") {
              update = builders.objectExpression(update.properties);
            }
            if (where.type === "ObjectExpression") {
              where = builders.objectExpression(where.properties);
            }

            path.replace(
              builders.callExpression(path.node.callee, [
                sql,
                builders.objectExpression([
                  builders.objectProperty(
                    builders.identifier("update"),
                    update,
                    false,
                    update.type === "Identifier" && update.name === "update",
                  ),
                  builders.objectProperty(
                    builders.identifier("where"),
                    where,
                    false,
                    where.type === "Identifier" && where.name === "where",
                  ),
                  ...(resultIsUsed
                    ? [
                        builders.objectProperty(
                          builders.identifier("returning"),
                          builders.stringLiteral("*"),
                          false,
                          false,
                        ),
                      ]
                    : []),
                ]),
              ]),
            );

            replaceCount++;
            didReplace = true;

            this.traverse(path);
          },
        });

        if (didReplace) {
          modifiedFileCount++;
          filesToWrite[file] = recast.print(ast).code;
        }
      }),
    );
  }

  // Only write if no error is thrown
  for (const [file, source] of Object.entries(filesToWrite)) {
    await writeFile(file, source, "utf-8");
  }

  return {
    callCount: replaceCount,
    fileCount: modifiedFileCount,
    possibleInvalidCalls,
  };
}

/**
 * Parse a file, enabling typescript and jsx parsers when necessary
 *
 * @param {string} file
 * @param {string} contents
 * @returns {Promise<File|any>}
 */
async function parseFile(file, contents) {
  let babel;

  try {
    babel = await import("@babel/parser");
  } catch (e) {
    throw new AppError("cli.codeMod.failedToLoadBabel", 500, {
      message:
        "Please install @compas/eslint-plugin, or @babel/parser directly.",
    });
  }

  const babelOpts = await import("recast/parsers/_babel_options.js");
  const opts = babelOpts.default.default();

  try {
    return recast.parse(contents, {
      parser: {
        parse(code) {
          if (file.endsWith(".ts")) {
            opts.plugins.push("typescript");
          } else if (file.endsWith(".tsx")) {
            opts.plugins.push("jsx", "typescript");
          } else if (file.endsWith(".jsx")) {
            opts.plugins.push("jsx");
          }

          return babel.parse(code, opts);
        },
      },
    });
  } catch (e) {
    throw new AppError(
      "cli.codeMod.failedToParseFile",
      500,
      {
        file,
      },
      e,
    );
  }
}
