import { readFile, writeFile } from "fs/promises";
import {
  AppError,
  eventStart,
  eventStop,
  isNil,
  newEventFromEvent,
  processDirectoryRecursive,
} from "@compas/stdlib";
import * as recast from "recast";
import { PARALLEL_COUNT } from "../constants.js";

/**
 * Convert `queries.entitySelect(sql, { ...where })` to `queryEntity({ where: { ...where
 * } }).exec(sql)`
 *
 * @param {InsightEvent} event
 * @param {boolean} verbose
 * @returns {Promise<void>}
 */
export async function executeCodeModVZeroDotZeroDotHundredFortySix(
  event,
  verbose,
) {
  const generatedFileList = await listGeneratedEntityFiles(
    newEventFromEvent(event),
  );

  if (verbose) {
    event.log.info({
      message: `Found ${generatedFileList.length} generated entity files.`,
    });
  }

  const collectedQueryBuilders = await collectGeneratedQueryEntityFunctions(
    newEventFromEvent(event),
    [...generatedFileList],
  );

  if (verbose) {
    event.log.info({
      message: `Found ${
        Object.keys(collectedQueryBuilders).length
      } 'queryEntity' functions in generated files.`,
      collectedQueryBuilders,
    });
  }

  const fullFileList = await listAllJavaScriptFiles(
    newEventFromEvent(event),
    generatedFileList,
  );

  if (verbose) {
    event.log.info({
      message: `Found ${fullFileList.length} js files in this project.`,
    });
  }

  if (verbose) {
    event.log.info({
      message: `Code-modding the found files, processing ${PARALLEL_COUNT} files in parallel.`,
    });
  }

  const { callCount, fileCount } = await modTheFiles(
    newEventFromEvent(event),
    collectedQueryBuilders,
    [...fullFileList],
  );

  if (verbose) {
    event.log.info({
      message: `Replaced ${callCount} call-sites to use the ${
        Object.keys(collectedQueryBuilders).length
      } generated query builders over ${fileCount} out of ${
        fullFileList.length
      } known files.`,
    });
  }
}

/**
 * Find generated database files
 *
 * @param {InsightEvent} event
 * @returns {Promise<string[]>}
 */
async function listGeneratedEntityFiles(event) {
  eventStart(event, "v00146.listGeneratedEntityFiles");

  const possibleFileList = [];

  await processDirectoryRecursive(process.cwd(), (file) => {
    if (file.match(/database\/\w+\.js$/gi) && !file.endsWith("index.js")) {
      possibleFileList.push(file);
    }
  });

  const result = [];

  // Double check that these files are generated
  while (possibleFileList.length) {
    const partial = possibleFileList.splice(0, PARALLEL_COUNT);

    await Promise.all(
      partial.map(async (file) => {
        const contents = await readFile(file, "utf-8");

        if (contents.startsWith("// Generated by @compas/code-gen")) {
          result.push(file);
        }
      }),
    );
  }

  eventStop(event);

  return result;
}

/**
 * Parse the reactQueries.tsx files and collect the hooks based on 'useXxxXxx'
 *
 * @param {InsightEvent} event
 * @param {string[]} fileList
 * @returns {Promise<Object<string, { queryBuilder: string, entityName: string, }>>}
 */
async function collectGeneratedQueryEntityFunctions(event, fileList) {
  eventStart(event, "v00146.collectGeneratedQueryEntityFunctions");

  const result = {};

  while (fileList.length) {
    const partial = fileList.splice(0, PARALLEL_COUNT);

    await Promise.all(
      partial.map(async (file) => {
        const contents = await readFile(file, "utf-8");

        const ast = await parseFile(file, contents);

        const nodes = ast.program.body
          .filter((it) => it.type === "ExportNamedDeclaration")
          .map((it) => it.declaration)
          .filter((it) => it.type === "FunctionDeclaration");

        for (const node of nodes) {
          if (!node.id.name.match(/^query\w+/gi)) {
            continue;
          }

          let namePartial = node.id.name.split("query")[1].split("");

          // queries.entityFooSelect vs queryEntityFoo
          namePartial[0] = namePartial[0].toLowerCase();
          namePartial = namePartial.join("");

          result[`${namePartial}Select`] = {
            queryBuilder: node.id.name,
            entityName: namePartial,
          };
        }
      }),
    );
  }

  eventStop(event);

  return result;
}

/**
 * Find all js files, excluding the generated ones
 *
 * @param {InsightEvent} event
 * @param {string[]} generatedFiles
 * @returns {Promise<string[]>}
 */
async function listAllJavaScriptFiles(event, generatedFiles) {
  eventStart(event, "v00146.listAllJavaScriptFiles");

  const result = [];

  await processDirectoryRecursive(process.cwd(), (file) => {
    if (!file.endsWith(".js")) {
      return;
    }

    if (generatedFiles.includes(file)) {
      return;
    }

    result.push(file);
  });

  eventStop(event);

  return result;
}

/**
 * Replace the call-sites and imports
 *
 * @param {InsightEvent} event
 * @param {Object<string, {
 *     queryBuilder: string,
 *     entityName: string,
 *  }>} knownQueryBuilderCalls
 * @param {string[]} fileList
 * @returns {Promise<{ callCount: number, fileCount: number }>}
 */
async function modTheFiles(event, knownQueryBuilderCalls, fileList) {
  eventStart(event, "v00146.modTheFiles");

  const builders = recast.types.builders;

  const filesToWrite = {};
  let replaceCount = 0;
  let modifiedFileCount = 0;

  while (fileList.length) {
    event.log.info({
      fileList: fileList.length,
      replaceCount,
      modifiedFileCount,
    });

    const partial = fileList.splice(0, PARALLEL_COUNT);

    await Promise.all(
      partial.map(async (file) => {
        let didReplace = false;
        const contents = await readFile(file, "utf-8");

        // We only supported destructured 'queries' imports, so skip parsing if the file
        // doesn't include such an instance.
        if (!contents.includes("queries")) {
          return;
        }

        const ast = await parseFile(file, contents);

        const queriesImports = {};
        const queryEntityImports = [];

        // From:
        // import { queries } from "./generated/database/index.js
        // or: import { queries as fooQueries } from "../generated/database.index.js
        // or: import { queries } from "./generated.js"
        //
        // Extract:
        //  queries -> ./generated/database/
        //  or: fooQueries -> ../generated/database/
        //  or: queries -> ./generated/database.js
        //
        // visitImportDeclaration
        //   for .specifiers
        //     .imported.name === "queries"
        //     save .local.name with $root.source.value trimmed to database/
        recast.visit(ast, {
          visitImportDeclaration(path) {
            for (const specifier of path.node.specifiers) {
              if (specifier.imported?.name === "queries") {
                const splitPath = path.node.source.value.split("/database/");

                if (splitPath.length !== 1) {
                  // remove /index.js
                  splitPath.pop();

                  queriesImports[specifier.local.name] = `${splitPath.join(
                    "/database/",
                  )}/database/`;
                } else if (splitPath[0].endsWith("./generated.js")) {
                  queriesImports[specifier.local.name] = splitPath[0].replace(
                    ".js",
                    "/database/",
                  );
                }
              }

              // Also save existing imports for `queryEntity` calls, so we don't add
              // duplicate imports
              if (
                specifier.imported?.name.match(/^query\w+$/gi) &&
                specifier.imported.name === specifier.local.name &&
                path.node.source.value.includes("/database/")
              ) {
                queryEntityImports.push(specifier.imported.name);
              }
            }

            this.traverse(path);
          },
        });

        // No `queries` imports found, so ignore this file
        if (Object.keys(queriesImports).length === 0) {
          return;
        }

        // From:
        // aaa.bbbb(sql, where?)
        // check if aaa is an imported 'queries',
        // check if bbb is a select call
        // replace with queryBbbb({ where }?).exec(sql)
        //
        // visitCallExpression
        // .callee.type === "MemberExpression
        // .callee.object.name === "queries"
        // .callee.property.name in knownQueryBuilderCalls
        recast.visit(ast, {
          visitCallExpression(path) {
            if (path.node.callee.type !== "MemberExpression") {
              this.traverse(path);
              return;
            }

            // Check if object is an imported 'queries'
            if (isNil(queriesImports[path.node.callee.object.name])) {
              this.traverse(path);
              return;
            }

            // Check if .property is an known entitySelect
            if (isNil(knownQueryBuilderCalls[path.node.callee.property.name])) {
              this.traverse(path);
              return;
            }

            const selectedImportPath =
              queriesImports[path.node.callee.object.name];
            const selectedEntity =
              knownQueryBuilderCalls[path.node.callee.property.name];

            // Add import
            if (!queryEntityImports.includes(selectedEntity.queryBuilder)) {
              // Add it, so we don't add duplicate imports
              queryEntityImports.push(selectedEntity.queryBuilder);

              const fullImportPath = `${
                selectedImportPath + selectedEntity.entityName
              }.js`;

              ast.program.body.unshift(
                builders.importDeclaration(
                  [
                    builders.importSpecifier(
                      builders.identifier(selectedEntity.queryBuilder),
                      builders.identifier(selectedEntity.queryBuilder),
                    ),
                  ],
                  builders.stringLiteral(fullImportPath),
                ),
              );
            }

            // Replace call
            const [sql, where] = path.node.arguments;
            path.replace(
              builders.callExpression(
                builders.memberExpression(
                  builders.callExpression(
                    builders.identifier(selectedEntity.queryBuilder),
                    isNil(where)
                      ? []
                      : [
                          builders.objectExpression([
                            builders.objectProperty(
                              builders.identifier("where"),
                              where,
                              false,
                              where.type === "Identifier" &&
                                where.name === "where",
                            ),
                          ]),
                        ],
                  ),
                  builders.identifier("exec"),
                ),
                [sql],
              ),
            );

            replaceCount++;
            didReplace = true;

            this.traverse(path);
          },
        });

        if (didReplace) {
          event.log.info({
            message: `Replaced in ${file}`,
          });
          modifiedFileCount++;
          filesToWrite[file] = recast.print(ast).code;
        }
      }),
    );
  }

  // Only write if no error is thrown
  for (const [file, source] of Object.entries(filesToWrite)) {
    await writeFile(file, source, "utf-8");
  }

  eventStop(event);

  return {
    callCount: replaceCount,
    fileCount: modifiedFileCount,
  };
}

/**
 * Parse a file, enabling typescript and jsx parsers when necessary
 *
 * @param {string} file
 * @param {string} contents
 * @returns {Promise<File|any>}
 */
async function parseFile(file, contents) {
  let babel;

  try {
    babel = await import("@babel/parser");
  } catch (e) {
    throw new AppError("cli.codeMod.failedToLoadBabel", 500, {
      message: "Please install @compas/lint-config, or @babel/parser directly.",
    });
  }

  const babelOpts = await import("recast/parsers/_babel_options.js");
  const opts = babelOpts.default.default();

  try {
    return recast.parse(contents, {
      parser: {
        parse(code) {
          if (file.endsWith(".ts")) {
            opts.plugins.push("typescript");
          } else if (file.endsWith(".tsx")) {
            opts.plugins.push("jsx", "typescript");
          } else if (file.endsWith(".jsx")) {
            opts.plugins.push("jsx");
          }

          return babel.parse(code, opts);
        },
      },
    });
  } catch (e) {
    throw new AppError(
      "cli.codeMod.failedToParseFile",
      500,
      {
        file,
      },
      e,
    );
  }
}
