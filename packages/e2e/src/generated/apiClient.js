// Generated by @lbu/code-gen 2020-03-29T17:41:07.535Z

import * as mocks from "./mocks.js";

let _internalClient = undefined;

function checkApiClient() {
  if (_internalClient === undefined) {
    throw new Error("Initialize api client with createApiClient");
  }
}

/**
 * Should set an axios compatible api client
 * @param {AxiosInstance} instance
 */
export function createApiClient(instance) {
  _internalClient = instance;
}

function setXRequestId(headers) {
  _internalClient.defaults.headers.common["X-Request-Id"] =
    headers["x-request-id"];
}

export const todo = {
  /**
 * Name: all
 * Tags: 
 * Docs: 
 * @return {Promise.<TodoAllResponse>}


 */
  all: async function () {
    checkApiClient();

    try {
      const response = await _internalClient.request({
        url: `/todo/`,
        method: "get",
        params: {},
        data: {},
      });

      setXRequestId(response.headers);

      return response.data;
    } catch (e) {
      if (e.response && e.response.status === 405) {
        return mocks.mockTodoAllResponse();
      }
      throw e;
    }
  },

  /**
 * Name: one
 * Tags: 
 * Docs: 
 * @param { TodoNameParam_Optional} params


 * @return {Promise.<TodoListResponse>}


 */
  one: async function (params) {
    checkApiClient();

    try {
      const response = await _internalClient.request({
        url: `/todo/${params.name}`,
        method: "get",
        params: {},
        data: {},
      });

      setXRequestId(response.headers);

      return response.data;
    } catch (e) {
      if (e.response && e.response.status === 405) {
        return mocks.mockTodoListResponse();
      }
      throw e;
    }
  },

  /**
 * Name: new
 * Tags: 
 * Docs: 
 * @param { TodoNewBody_Optional} body


 * @return {Promise.<TodoListResponse>}


 */
  new: async function (body) {
    checkApiClient();

    try {
      const response = await _internalClient.request({
        url: `/todo/`,
        method: "post",
        params: {},
        data: body,
      });

      setXRequestId(response.headers);

      return response.data;
    } catch (e) {
      if (e.response && e.response.status === 405) {
        return mocks.mockTodoListResponse();
      }
      throw e;
    }
  },

  /**
 * Name: createItem
 * Tags: 
 * Docs: 
 * @param { TodoNameParam_Optional} params


 * @param { TodoCreateItemBody_Optional} body


 * @return {Promise.<TodoListResponse>}


 */
  createItem: async function (
    params,

    body,
  ) {
    checkApiClient();

    try {
      const response = await _internalClient.request({
        url: `/todo/${params.name}/item/`,
        method: "post",
        params: {},
        data: body,
      });

      setXRequestId(response.headers);

      return response.data;
    } catch (e) {
      if (e.response && e.response.status === 405) {
        return mocks.mockTodoListResponse();
      }
      throw e;
    }
  },

  /**
 * Name: toggleItem
 * Tags: 
 * Docs: 
 * @param { TodoNameParam_Optional} params


 * @param { TodoToggleItemBody_Optional} body


 * @return {Promise.<TodoListResponse>}


 */
  toggleItem: async function (
    params,

    body,
  ) {
    checkApiClient();

    try {
      const response = await _internalClient.request({
        url: `/todo/${params.name}/item/toggle`,
        method: "post",
        params: {},
        data: body,
      });

      setXRequestId(response.headers);

      return response.data;
    } catch (e) {
      if (e.response && e.response.status === 405) {
        return mocks.mockTodoListResponse();
      }
      throw e;
    }
  },

  /**
 * Name: delete
 * Tags: 
 * Docs: 
 * @param { TodoNameParam_Optional} params


 * @return {Promise.<TodoDeleteResponse>}


 */
  delete: async function (params) {
    checkApiClient();

    try {
      const response = await _internalClient.request({
        url: `/todo/${params.name}`,
        method: "delete",
        params: {},
        data: {},
      });

      setXRequestId(response.headers);

      return response.data;
    } catch (e) {
      if (e.response && e.response.status === 405) {
        return mocks.mockTodoDeleteResponse();
      }
      throw e;
    }
  },
};

export const unimplemented = {
  /**
 * Name: user
 * Tags: 
 * Docs: 
 * @return {Promise.<User>}


 */
  user: async function () {
    checkApiClient();

    try {
      const response = await _internalClient.request({
        url: `/unimplemented/user`,
        method: "get",
        params: {},
        data: {},
      });

      setXRequestId(response.headers);

      return response.data;
    } catch (e) {
      if (e.response && e.response.status === 405) {
        return mocks.mockUser();
      }
      throw e;
    }
  },

  /**
 * Name: settings
 * Tags: 
 * Docs: 
 * @return {Promise.<UnimplementedSettingsResponse>}


 */
  settings: async function () {
    checkApiClient();

    try {
      const response = await _internalClient.request({
        url: `/unimplemented/settings`,
        method: "get",
        params: {},
        data: {},
      });

      setXRequestId(response.headers);

      return response.data;
    } catch (e) {
      if (e.response && e.response.status === 405) {
        return mocks.mockUnimplementedSettingsResponse();
      }
      throw e;
    }
  },
};

export const lbu = {
  /**
 * Name: structure
 * Tags: _lbu
 * Docs: Return the full generated structure as a json object.

 * @return {Promise.<*>}


 */
  structure: async function () {
    checkApiClient();

    const response = await _internalClient.request({
      url: `/_lbu/structure.json`,
      method: "get",
      params: {},
      data: {},
    });

    setXRequestId(response.headers);

    return response.data;
  },
};
